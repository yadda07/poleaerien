
# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PoleAerien
                                 A QGIS plugin
 Controle de donner comac
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2022 by SOUMARE Abdoulayi
        email                : abdoulayisoumare@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox
from qgis.core import QgsProject, QgsMapLayer, QgsWkbTypes
from PyQt5.QtWidgets import QInputDialog

from shapely.geometry import shape
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
# from .Cap_Comac_dialog import CapComacDialog
from .Pole_Aerien_dialog import PoleAerienDialog
import os.path
# import re
import datetime
import time
# import pandas as pd
# import numpy as np
from tabulate import tabulate
# from openpyxl.styles import PatternFill
from . import Initiatlisation
from .aboutdialog import PoleAerienAboutDialog
from .SecondFile import *
from .Maj_Ft_Bt import *
from .PoliceC6 import *
from .Comac import *
from .CapFt import *
from .C6_vs_Bd import *
from .C6_vs_C3A_vs_Bd import *
from functools import reduce

"""
pyrcc5 resources.qrc -o resources.py
ou lks

python -m PyQt5.pyrcc_main resource.qrc -o resource_rc.py
pyuic5 Cap_Comac_dialog_base.ui -o ../Cap_Comac_dialog_base.py
pyuic5 PoleAerien_dialog_base.ui -o ../PoleAerien_dialog_base.py
python -m PyQt5.pyuic5_main PoleAerien_dialog_base.ui -o PoleAerien_dialog_base.py
pyuic5 PoleAerien_apropos.ui -o ../PoleAerien_apropos.py
conda install spyder=5.3.3
"""


class PoleAerien:
    """QGIS Plugin Implementation."""
    MSG_BOX_TITLE = "Plugin d'analyse des données Pôle Aérien"

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(self.plugin_dir, 'i18n', f'PoleAerien_{locale}.qm')

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Fonction pour déplacer l'icone de plugin
        self.toolbar = self.iface.addToolBar(u'&Pôle Aérien')
        self.toolbar.setObjectName(u'&Pôle Aérien')

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Pôle Aérien')

        # self.dlg = CapComacDialog()
        self.dlg = PoleAerienDialog()
        self.sc = SecondFile()
        self.maj = MajFtBt()
        self.com = Comac()
        self.cap = CapFt()
        self.c6bd = C6_vs_Bd()
        self.c6c3aBd = C6_vs_C3A_vs_Bd()
        self.police = PoliceC6()
        self.init = Initiatlisation()

        # tb_cmd = "cmd"
        # tb_decoupage = "decoupage"
        # champs_decoupage = "ref_fci"
        # valeur_champs_dcp = "DI_1"

        # Bouton d'aide affichant les informations utiles
        self.dlg.helpButton.clicked.connect(self.helpAbout)
        self.msgexporter = str()
        ################################## MAJ #########################################
        self.dlg.MajrafraichirUi.clicked.connect(self.rafraichisementMaj)

        self.dlg.majBdLanceur.clicked.connect(self.majDesDonnneesFtBt)
        self.dlg.MajcomboBox_infra_pt_pot.currentTextChanged.connect(self.cocherDecocherAucunMaj)
        self.dlg.MajcomboBox_etude_cap_ft.currentTextChanged.connect(self.cocherDecocherAucunMaj)
        self.dlg.MajcomboBox_etude_comac.currentTextChanged.connect(self.cocherDecocherAucunMaj)

        self.dlg.MajlienCheminFichierExcel.textChanged.connect(self.cocherDecocherAucunMaj)

        self.dlg.MajboutonCheminFichier.clicked.connect(self.cheminDossierRepertoireMaj)

        ################################## VERIF CAP_FT  #########################################
        # Rafraîchir l'interface utilisateur de QGIS (les tables)
        self.dlg.capFtRafraichirUi.clicked.connect(self.rafraichisement)
        # Sélection du repertoire où sera stocké les fichiers
        self.dlg.boutonCheminEtudeCapFt.clicked.connect(self.cheminDossierRepertoireCapFT)
        # select directory where save files
        self.dlg.boutonCheminExportCapFt.clicked.connect(self.cheminDossierExportAnalyse)

        # Valeurs des études servant à l'analyse.
        # Valeurs des colonnes
        self.dlg.capFtComboBox_etude_cap_ft.currentTextChanged.connect(self.champsColonneCapFt)

        # Action associé au bouton principal pour lancer l'analyse du fichier
        self.dlg.cap_ftLanceur.clicked.connect(self.analyserFichiersCapFt)

        self.dlg.boutonCheminExport.clicked.connect(self.repertoireFichierTxtMessage)
        self.dlg.exporter.clicked.connect(self.exporterFichierTxt)

        # Bouton cocher permettant de rendre fonction l'exécution du code
        # (Aucun, uniquement les entités séléctionnées, ou tous

        self.dlg.capFtComboBoxCoucheInfra_pt_pot.currentTextChanged.connect(self.cocherDecocherAucun)
        self.dlg.capFtComboBox_etude_cap_ft.currentTextChanged.connect(self.cocherDecocherAucun)
        self.dlg.capFtComboBoxChampsCapFt.currentTextChanged.connect(self.cocherDecocherAucun)
        self.dlg.lienRepertoireCapFt.textChanged.connect(self.cocherDecocherAucun)
        self.dlg.lienCheminExportCapFt.textChanged.connect(self.cocherDecocherAucun)

        self.dlg.capFtRafraichirUi.setStyleSheet("background-color: #addd8e")
        self.dlg.cap_ftLanceur.setStyleSheet("background-color: #FFA500")

        ################################## VERIF COMAC  #########################################
        # Rafraîchir l'interface utilisateur de QGIS (les tables)
        self.dlg.comacRafraichirUi.clicked.connect(self.rafraichisement)

        # Action associé au bouton principal pour lancer l'analyse du fichier
        self.dlg.cap_comacLanceur.clicked.connect(self.analyserFichiersComac)

        self.dlg.comboBoxCoucheComac.currentTextChanged.connect(self.champsColonneComac)

        self.dlg.boutonCheminExportComac.clicked.connect(self.cheminDossierExportAnalyse)

        self.dlg.comacComboBoxCoucheInfra_pt_pot.currentTextChanged.connect(self.cocherDecocherAucun)
        self.dlg.comboBoxCoucheComac.currentTextChanged.connect(self.cocherDecocherAucun)
        self.dlg.comboBoxChampsComac.currentTextChanged.connect(self.cocherDecocherAucun)
        self.dlg.lienCheminExportComac.textChanged.connect(self.cocherDecocherAucun)

        self.dlg.boutonCheminEtudeComac.clicked.connect(self.cheminDossierRepertoireComac)
        self.dlg.lienRepertoireComac.textChanged.connect(self.cocherDecocherAucun)

        self.dlg.comboBoxChampsComac.currentTextChanged.connect(self.cocherDecocherAucun)

        self.dlg.cap_comacLanceur.setStyleSheet("background-color: #3182bd")

        ########### COMPARER C6 des données de la BD  #########################################
        self.dlg.C6BdRafraichirUi.clicked.connect(self.rafraichisementC6Bd)

        self.dlg.C6BdcomboBox_infra_pt_pot.currentTextChanged.connect(self.cocherDecocherAucunC6Bd)
        self.dlg.C6BdcomboBox_etude_cap_ft.currentTextChanged.connect(self.cocherDecocherAucunC6Bd)
        self.dlg.C6BdcomboBox_etude_cap_ft.currentTextChanged.connect(self.champsColonneCapFtC6Bd)
        self.dlg.lienCheminFichiersC6.textChanged.connect(self.cocherDecocherAucunC6Bd)
        self.dlg.lienCheminExportDonnees.textChanged.connect(self.cocherDecocherAucunC6Bd)

        self.dlg.C6BdLanceur.clicked.connect(self.comparaisonC6BaseDonnees)

        self.dlg.C6BdboutonCheminFichiersC6.clicked.connect(self.cheminDossierRepertoireC6)
        self.dlg.C6BdboutonCheminExportDonnees.clicked.connect(self.cheminDossierExportAnalyse)
        self.dlg.C6BdLanceur.setStyleSheet("background-color: #3182bd")

        ########### COMPARER C6, C3A, C6 et C7 en même temps #########################################

        # df = pd.DataFrame(columns=["N° appui", "Nature des travaux", "Études"], dtype="float64")
        #
        # self.c6c3aBd.LectureFichiersExcelsC6(df, "")
        self.dlg.rafraichirUi_c6_c3a_bd.clicked.connect(self.rafraichisementC6C3aBd)
        self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.currentTextChanged.connect(self.cocherDecocherAucunC6C7C3aBd)
        self.dlg.comboBox_Cmd_c6_c3a_bd.currentTextChanged.connect(self.cocherDecocherAucunC6C7C3aBd)
        self.dlg.comboBox_Decoupage.currentTextChanged.connect(self.cocherDecocherAucunC6C7C3aBd)
        self.dlg.comboBox_Dcp_champs.currentTextChanged.connect(self.cocherDecocherAucunC6C7C3aBd)
        self.dlg.comboBox_Dcp_Valeur_champs.currentTextChanged.connect(self.cocherDecocherAucunC6C7C3aBd)
        self.dlg.radioButtonQgis.clicked.connect(self.cocherDecocherAucunC6C7C3aBd)

        self.dlg.radioButtonExcel.clicked.connect(self.cocherDecocherAucunC6C7C3aBd)

        self.dlg.comboBox_Decoupage.currentTextChanged.connect(self.valeurChampsDecoupage)
        self.dlg.comboBox_Decoupage.currentTextChanged.connect(self.plc6champsDecoupage)

        self.dlg.comboBox_Dcp_champs.currentTextChanged.connect(self.valeurChampsDecoupage)

        self.dlg.lienCheminC6_c6_c3a_bd.textChanged.connect(self.cocherDecocherAucunC6C7C3aBd)
        self.dlg.lienCheminC3A_c6_c3a_bd.textChanged.connect(self.cocherDecocherAucunC6C7C3aBd)
        self.dlg.lienCheminC7_c6_c3a_bd.textChanged.connect(self.cocherDecocherAucunC6C7C3aBd)
        self.dlg.lienCheminExportDonnees_c6_c3a_bd.textChanged.connect(self.cocherDecocherAucunC6C7C3aBd)

        self.dlg.c6_c3a_bdLanceur.clicked.connect(self.comparaisonC6C3aBd)

        # self.dlg.boutonCheminFichiersC6.clicked.connect(self.cheminDossierRepertoireC6)
        self.dlg.boutonCheminExportDonnees_c6_c3a_bd.clicked.connect(self.cheminDossierExportAnalyse)

        self.dlg.boutonCheminC6_c6_c3a_bd.clicked.connect(self.fichierC6)
        self.dlg.boutonCheminC3A_c6_c3a_bd.clicked.connect(self.fichierC3A)
        self.dlg.boutonCheminC7_c6_c3a_bd.clicked.connect(self.fichierC7)

        self.dlg.radioButtonQgis.clicked.connect(self.QgisOuExcelC3A)
        self.dlg.radioButtonExcel.clicked.connect(self.QgisOuExcelC3A)
        self.dlg.c6_c3a_bdLanceur.setStyleSheet("background-color: #d95f0e")

        self.dlg.comboBox_Cmd_c6_c3a_bd.setStyleSheet("background-color: #a1d99b")
        self.dlg.boutonCheminC3A_c6_c3a_bd.setStyleSheet("background-color: #f1eef6")

        ########################## POLICE C6 #########################################
        # Fonction utilisée lorsqu'on clic sur le bouton associe au fichier de comparaisonPP
        self.dlg.c6BoutonCheminImport.clicked.connect(self.choixDossierImportFichierC6)

        # Sélection du repertoire où sera stocké les fichiers
        self.dlg.boutonCheminGraceThd.clicked.connect(self.plc6ChoixDossierRepertoireGraceTHD)

        # Rafraîchir l'interface utilisateur de QGIS (les tables)
        self.dlg.plcC6Rafraichir.clicked.connect(self.plc6Rafraichisement)

        # Action associé au bouton principal pour lancer l'analyse du fichier
        self.dlg.c6Lanceur.clicked.connect(self.plc6analyserGlobal)

        self.dlg.exporter.clicked.connect(self.exporterFichierTxt)
        # Autre manière de faire
        # self.dlg.exporter.clicked.connect(self.exporterFichierTxt(self.msgexporter))

        # Valeurs des études servant à l'analyse.
        # Valeurs des colonnes
        self.dlg.c6ComboBoxCoucheEtudes.currentTextChanged.connect(self.plc6ColonneCombobox)

        # Colonnes
        self.dlg.c6comboBoxColonneDecoupage.currentTextChanged.connect(self.plc6ValeurCombobox)
        self.dlg.c6ComboBoxCoucheBpe.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6ComboBoxCoucheAttaches.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6ComboBoxCoucheEtudes.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6comboBoxColonneDecoupage.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6ComboBoxValeur.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6LienCheminGraceThd.textChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.C6LienCheminImportFichier.textChanged.connect(self.plc6CocherDecocherAucun)

        self.dlg.c6Lanceur.setStyleSheet("background-color: #a1d99b")

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CapComac', message)

    def add_action( self, icon_path, text, callback, enabled_flag=True, add_to_menu=True,
                    add_to_toolbar=True, status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            # self.iface.addToolBarIcon(action)

            # Fonction pour déplacer l'icone de plugin
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/PoleAerien/icon.png'

        self.add_action(
            icon_path,
            text=self.tr(u'Pôle Aérien'),
            callback=self.run,
            parent=self.iface.mainWindow())

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Pôle Aérien'),
                action)
            self.iface.removeToolBarIcon(action)

        # Supression de l'icone de plugin
        del self.toolbar

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def helpAbout(self):
        # set the version

        self.aboutDlg = PoleAerienAboutDialog()

        # add version to the label
        self.aboutDlg.uiAbout.version_n.setText(self.init.version())

        self.aboutDlg.uiAbout.autors_name.setText(self.init.authorName())

        # show dialog
        self.aboutDlg.show()

    def alerteInfos(self, message, efface=False, couleur="red"):
        """Fonction pour afficher des messages d'alerte dans la barre d'info"""
        if efface:
            self.dlg.textBrowser.clear()

        self.dlg.textBrowser.setTextColor(QColor(couleur))
        self.dlg.textBrowser.append(f"{message}\n")

    # def alerteInfos(self, message, efface=False, couleur="red"):
    #     """Fonction pour afficher des messages d'alerte dans la barre d'info"""
    #     if efface:
    #         self.dlg.textBrowser.clear()
    #
    #     self.dlg.textBrowser.setTextColor(QColor(couleur))
    #     self.dlg.textBrowser.append(f"{message}\n")

    def QgisOuExcelC3A(self):
        """Pour rendre l'interface interactive si l'utilisation souhaite utilisée QGIS ou s'il souhaite utilisé les
        données C3A au format Excel"""
        if self.dlg.radioButtonQgis.isChecked():
            self.dlg.comboBox_Cmd_c6_c3a_bd.setEnabled(True)
            self.dlg.boutonCheminC3A_c6_c3a_bd.setEnabled(False)

            self.dlg.comboBox_Cmd_c6_c3a_bd.setStyleSheet("background-color: #a1d99b")
            self.dlg.boutonCheminC3A_c6_c3a_bd.setStyleSheet("background-color: #f1eef6")

        else:
            self.dlg.comboBox_Cmd_c6_c3a_bd.setStyleSheet("background-color: #f1eef6")
            self.dlg.boutonCheminC3A_c6_c3a_bd.setStyleSheet("background-color: #a1d99b")

            self.dlg.comboBox_Cmd_c6_c3a_bd.setEnabled(False)
            self.dlg.boutonCheminC3A_c6_c3a_bd.setEnabled(True)

    def cocherDecocherAucunMaj(self):
        """Fonction pour cocher ou décocher l'interface de la phase 2"""
        ############################# ANALYSE COMAC ####################################
        if (not self.dlg.MajcomboBox_infra_pt_pot.currentText() or
                not os.path.exists(self.dlg.MajlienCheminFichierExcel.text()) or
                not self.dlg.MajcomboBox_etude_cap_ft.currentText() or
                not self.dlg.MajcomboBox_etude_comac.currentText()):
            self.dlg.majBdLanceur.setEnabled(False)
        else:
            self.dlg.majBdLanceur.setEnabled(True)

    def cocherDecocherAucun(self):
        """Fonction pour cocher ou décocher l'interface de la phase 2"""
        ############################# ANALYSE COMAC ####################################
        if (not self.dlg.comacComboBoxCoucheInfra_pt_pot.currentText() or
                not os.path.isdir(self.dlg.lienRepertoireComac.text()) or
                not os.path.isdir(self.dlg.lienCheminExportComac.text()) or
                not self.dlg.comboBoxCoucheComac.currentText() or
                not self.dlg.comboBoxChampsComac.currentText()):
            self.dlg.cap_comacLanceur.setEnabled(False)
        else:
            self.dlg.cap_comacLanceur.setEnabled(True)

        ############################# ANALYSE CAP_FT ####################################
        if (not self.dlg.capFtComboBoxCoucheInfra_pt_pot.currentText() or
                not self.dlg.capFtComboBox_etude_cap_ft.currentText() or
                not self.dlg.capFtComboBoxChampsCapFt.currentText() or
                not os.path.isdir(self.dlg.lienRepertoireCapFt.text()) or
                not os.path.isdir(self.dlg.lienCheminExportCapFt.text())):
            self.dlg.cap_ftLanceur.setEnabled(False)

        else:
            self.dlg.cap_ftLanceur.setEnabled(True)

    def cocherDecocherAucunC6Bd(self):
        """Fonction pour cocher ou décocher l'interface de la phase 2"""
        ############################# ANALYSE COMAC ####################################
        if (not self.dlg.C6BdcomboBox_infra_pt_pot.currentText() or
                not self.dlg.C6BdcomboBox_etude_cap_ft.currentText() or
                not os.path.isdir(self.dlg.lienCheminFichiersC6.text()) or
                not os.path.isdir(self.dlg.lienCheminExportDonnees.text())):
            self.dlg.C6BdLanceur.setEnabled(False)

        else:
            if self.dlg.C6BdcomboBox_infra_pt_pot.currentText() == self.dlg.C6BdcomboBox_etude_cap_ft.currentText():
                self.dlg.C6BdLanceur.setEnabled(False)
            else:
                self.dlg.C6BdLanceur.setEnabled(True)

    def cocherDecocherAucunC6C7C3aBd(self):
        """Fonction pour cocher ou décocher l'interface de la phase 2"""
        ############################# ANALYSE COMAC ####################################
        if (not self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.currentText() or
                not self.dlg.comboBox_Decoupage.currentText() or
                not self.dlg.comboBox_Dcp_champs.currentText() or
                not self.dlg.comboBox_Dcp_Valeur_champs.currentText() or
                not os.path.exists(self.dlg.lienCheminC6_c6_c3a_bd.text()) or
                not os.path.exists(self.dlg.lienCheminC7_c6_c3a_bd.text()) or
                not os.path.isdir(self.dlg.lienCheminExportDonnees_c6_c3a_bd.text())):
            self.dlg.c6_c3a_bdLanceur.setEnabled(True)
            self.dlg.c6_c3a_bdLanceur.setEnabled(False)

        else:
            if self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.currentText() == self.dlg.C6BdcomboBox_etude_cap_ft.currentText():
                self.dlg.c6_c3a_bdLanceur.setEnabled(False)

            elif self.dlg.radioButtonQgis.isChecked() and not self.dlg.comboBox_Cmd_c6_c3a_bd.currentText():
                self.dlg.c6_c3a_bdLanceur.setEnabled(False)

            elif self.dlg.radioButtonExcel.isChecked() and not os.path.exists(self.dlg.lienCheminC3A_c6_c3a_bd.text()):
                self.dlg.c6_c3a_bdLanceur.setEnabled(False)

            else:
                self.dlg.c6_c3a_bdLanceur.setEnabled(True)

    def cheminDossierRepertoireMaj(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self.dlg.progressBar.setValue(0)
        fnameC6 = QFileDialog.getOpenFileName(None, f"Veuillez sélectionner le fichier EXCEL FT BT KO", "", "Fichier (*.xlsx)")[0]

        # Pour changer le dossier de travail par défaut
        if os.access(fnameC6, os.W_OK):
            self.dlg.MajlienCheminFichierExcel.setText(fnameC6)
            dossier = os.path.dirname(fnameC6)
            os.chdir(dossier)
            return

    def cheminDossierRepertoireComac(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self.dlg.progressBar.setValue(0)
        repertoire = QFileDialog.getExistingDirectory(self.dlg,
                                                      f"Sélectionner le répertoire contenant les fichiers COMAC", "")
        if os.access(repertoire, os.W_OK):
            self.dlg.lienRepertoireComac.setText(repertoire)
            self.dlg.lienRepertoireComac.setStyleSheet("""QLineEdit {background-color: white; }""")

    def cheminDossierRepertoireCapFT(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self.dlg.progressBar.setValue(0)
        repertoire = QFileDialog.getExistingDirectory(self.dlg,
                                                      f"Sélectionner le répertoire contenant les fichiers CAP_FT", "")
        if os.access(repertoire, os.W_OK):
            self.dlg.lienRepertoireCapFt.setText(repertoire)
            self.dlg.lienRepertoireCapFt.setStyleSheet("""QLineEdit {background-color: white; }""")

    def cheminDossierRepertoireC6(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self.dlg.progressBar.setValue(0)
        repertoire = QFileDialog.getExistingDirectory(self.dlg,
                                                      f"Sélectionner le répertoire contenant les fichiers C6", "")
        if os.access(repertoire, os.W_OK):
            self.dlg.lienCheminFichiersC6.setText(repertoire)
            self.dlg.lienCheminFichiersC6.setStyleSheet("""QLineEdit {background-color: white; }""")

    def cheminDossierExportAnalyse(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self.dlg.progressBar.setValue(0)
        exportAnalyse = QFileDialog.getExistingDirectory(self.dlg,
                                                         f"Sélectionner le répertoire d'export de l'analyse", "")

        if os.access(exportAnalyse, os.W_OK):
            self.dlg.lienCheminExportComac.setText(exportAnalyse)
            self.dlg.lienCheminExportComac.setStyleSheet("""QLineEdit {background-color: white; }""")

            self.dlg.lienCheminExportDonnees.setText(exportAnalyse)
            self.dlg.lienCheminExportDonnees.setStyleSheet("""QLineEdit {background-color: white; }""")

            self.dlg.lienCheminExportDonnees_c6_c3a_bd.setText(exportAnalyse)
            self.dlg.lienCheminExportDonnees_c6_c3a_bd.setStyleSheet("""QLineEdit {background-color: white; }""")

            self.dlg.lienCheminExportCapFt.setText(exportAnalyse)
            self.dlg.lienCheminExportCapFt.setStyleSheet("""QLineEdit {background-color: white; }""")

    def repertoireFichierTxtMessage(self):
        """ Exporter le fichier txt contenant les messages affichés après execution du code."""
        self.dlg.progressBar.setValue(0)

        fichier_analyse = QFileDialog.getSaveFileName(self.dlg, f"Exporter des données d'ANALYSE ", "", '*.txt')
        repertoireTxtAnalyse = fichier_analyse[0]
        self.dlg.lienCheminExport.setText(repertoireTxtAnalyse)
        self.dlg.exporter.setEnabled(True)

    def exporterFichierTxt(self):
        """Fonction pour parcourir les fichiers Excel pour renseigner la référence des appuis."""
        self.dlg.progressBar.setValue(0)

        repertoireTxtAnalyse = self.dlg.lienCheminExport.text()
        # Set the path for the output file
        output_file = open(repertoireTxtAnalyse, 'w', encoding='utf-8')

        # Le message qui sera écrire dans le fichier
        if not self.msgexporter:
            alerte = f"Rien n'est disponible pour le fichier"
            self.alerteInfos(alerte)

        output_file.write(self.msgexporter)

        self.sc.alerteInfo(f"Le fichier d'analyse a bien été exporté")
        output_file.close()

    def fichierC6(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self.dlg.progressBar.setValue(0)
        fnameC6 = QFileDialog.getOpenFileName(None, f"Veuillez sélectionner le fichier EXCEL C6", "", "Fichier (*.xlsx)")[0]

        # Pour changer le dossier de travail par défaut
        if os.access(fnameC6, os.W_OK):
            self.dlg.lienCheminC6_c6_c3a_bd.setText(fnameC6)
            dossier = os.path.dirname(fnameC6)
            os.chdir(dossier)
            return

    def fichierC3A(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self.dlg.progressBar.setValue(0)
        fnameC6 = QFileDialog.getOpenFileName(None, f"Veuillez sélectionner le fichier EXCEL C3A", "", "Fichier (*.xlsx)")[0]

        # Pour changer le dossier de travail par défaut
        if os.access(fnameC6, os.W_OK):
            self.dlg.lienCheminC3A_c6_c3a_bd.setText(fnameC6)
            dossier = os.path.dirname(fnameC6)
            os.chdir(dossier)
            return

    def fichierC7(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self.dlg.progressBar.setValue(0)
        fnameC6 = QFileDialog.getOpenFileName(None, f"Veuillez sélectionner le fichier EXCEL C3A", "", "Fichier (*.xlsx)")[0]

        # Pour changer le dossier de travail par défaut
        if os.access(fnameC6, os.W_OK):
            self.dlg.lienCheminC7_c6_c3a_bd.setText(fnameC6)
            dossier = os.path.dirname(fnameC6)
            os.chdir(dossier)
            return

    def champsColonneComac(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs associée à la table sélectionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        champs_list = ['']
        self.dlg.comboBoxChampsComac.clear()

        for layer in layers:
            if layer.name() == self.dlg.comboBoxCoucheComac.currentText():
                # champs_list.append(str(champs.name()) for champs in layer.fields())
                for champs in layer.fields():
                    champs_list.append(str(champs.name()))

        if len(champs_list) == 1:
            self.dlg.comboBoxChampsComac.clear()

        else:
            # On insère des données colonnes dans le Combobox
            self.dlg.comboBoxChampsComac.addItems(champs_list)

            # On définit la valeur par défaut de la couche s'il y a un champs du nom de 'etude'
            regexp = re.compile(r'etudes*')
            for valeur in champs_list:
                if regexp.search(valeur.lower()):
                    self.dlg.comboBoxChampsComac.setCurrentIndex(champs_list.index(valeur))
                    break

    def champsColonneCapFt(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs
        colonne associée à la table sélectionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        champs_list = ['']
        self.dlg.capFtComboBoxChampsCapFt.clear()
        for layer in layers:
            if layer.name() == self.dlg.capFtComboBox_etude_cap_ft.currentText():
                # champs_list.append(str(champs.name()) for champs in layer.fields())
                for champs in layer.fields():
                    champs_list.append(str(champs.name()))  #  QVariant.String

        if len(champs_list) <= 1:
            self.dlg.capFtComboBoxChampsCapFt.clear()

        else:
            # On insère des données colonnes dans le Combobox
            self.dlg.capFtComboBoxChampsCapFt.addItems(champs_list)

            # On définit la valeur par défaut de la couche s'il y a un champs du nom de 'etude'
            regexp = re.compile(r'etudes*')
            for valeur in champs_list:
                if regexp.search(valeur.lower()):
                    self.dlg.capFtComboBoxChampsCapFt.setCurrentIndex(champs_list.index(valeur))
                    break

    def champsColonneCapFtC6Bd(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs
        colonne associée à la table sélectionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        champs_list = ['']
        self.dlg.C6BdcomboBoxChampsCapFt.clear()
        for layer in layers:
            if layer.name() == self.dlg.C6BdcomboBox_etude_cap_ft.currentText():
                # champs_list.append(str(champs.name()) for champs in layer.fields())
                for champs in layer.fields():
                    champs_list.append(str(champs.name()))  #  QVariant.String

        if len(champs_list) <= 1:
            self.dlg.C6BdcomboBoxChampsCapFt.clear()

        else:
            # print(f"champs_list : {champs_list}")
            # On insère des données colonnes dans le Combobox
            self.dlg.C6BdcomboBoxChampsCapFt.addItems(champs_list)

            # On définit la valeur par défaut de la couche s'il y a un champs du nom de 'etude'
            regexp = re.compile(r'etudes*')
            for valeur in champs_list:
                if regexp.search(valeur.lower()):
                    self.dlg.C6BdcomboBoxChampsCapFt.setCurrentIndex(champs_list.index(valeur))
                    break

    def rafraichisement(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.coucheCombobox_etude_comac()
        self.coucheCombobox_etude_cap_ft()
        self.coucheCombobox_infra_pt_pot()
        self.dlg.progressBar.setValue(0)

    def rafraichisementC6Bd(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.coucheCombobox_etude_cap_ft()
        self.coucheCombobox_etude_comac()
        self.coucheCombobox_infra_pt_pot()
        self.dlg.progressBar.setValue(0)

    def rafraichisementMaj(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.coucheCombobox_etude_cap_ft()
        self.coucheCombobox_etude_comac()
        self.coucheCombobox_infra_pt_pot()
        self.dlg.progressBar.setValue(0)

    def rafraichisementC6C3aBd(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.coucheCombobox_infra_pt_pot()
        self.coucheComboboxC3a()
        self.coucheComboboxDecoupage()
        self.dlg.progressBar.setValue(0)

    def coucheCombobox_infra_pt_pot(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        # On récupère ici la liste des tables présentes dans QGIS.
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        layer_list = ['']

        self.dlg.comacComboBoxCoucheInfra_pt_pot.clear()
        self.dlg.capFtComboBoxCoucheInfra_pt_pot.clear()
        self.dlg.C6BdcomboBox_infra_pt_pot.clear()
        self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.clear()
        self.dlg.MajcomboBox_infra_pt_pot.clear()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                try:
                    if QgsWkbTypes.geometryType(layer.wkbType()) in (0, 3):
                        layer_list.append(layer.name())

                except Exception as e:
                    print(f"Erreur comboboxCmd : {e}")
                    continue

        # Si absence de couche dans QGIS, on vide les combobox
        if len(layer_list) == 1:
            self.dlg.comacComboBoxCoucheInfra_pt_pot.clear()
            self.dlg.capFtComboBoxCoucheInfra_pt_pot.clear()
            self.dlg.C6BdcomboBox_infra_pt_pot.clear()
            self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.clear()
            self.dlg.MajcomboBox_infra_pt_pot.clear()
            self.alerteInfos("Votre projet ne contient aucun shape de type Point (infra_pt_pot, ...)")

        else:
            # On insère les données tables dans le Combobox
            layer_list.sort()
            self.dlg.comacComboBoxCoucheInfra_pt_pot.addItems(layer_list)
            self.dlg.capFtComboBoxCoucheInfra_pt_pot.addItems(layer_list)
            self.dlg.C6BdcomboBox_infra_pt_pot.addItems(layer_list)
            self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.addItems(layer_list)
            self.dlg.MajcomboBox_infra_pt_pot.addItems(layer_list)

            # On définit la valeur par défaut de la couche s'il y a un table du nom 'etude_cap_ft'
            for valeur in layer_list:
                regexp = re.compile(r'infra_pt_pot')
                if regexp.search(valeur.lower()):
                    self.dlg.comacComboBoxCoucheInfra_pt_pot.setCurrentIndex(layer_list.index(valeur))
                    self.dlg.capFtComboBoxCoucheInfra_pt_pot.setCurrentIndex(layer_list.index(valeur))
                    self.dlg.C6BdcomboBox_infra_pt_pot.setCurrentIndex(layer_list.index(valeur))
                    self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.setCurrentIndex(layer_list.index(valeur))
                    self.dlg.MajcomboBox_infra_pt_pot.setCurrentIndex(layer_list.index(valeur))
                    break

            # self.dlg.textBrowser.clear()

    def coucheCombobox_etude_comac(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        # On récupère ici la liste des tables présentes dans QGIS.

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        layer_list = ['']

        self.dlg.comboBoxCoucheComac.clear()
        self.dlg.MajcomboBox_etude_comac.clear()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                try:
                    if QgsWkbTypes.geometryType(layer.wkbType()) in (2, 5):
                        layer_list.append(layer.name())

                except Exception as e:
                    print(f"Erreur comboboxCmd : {e}")
                    continue

        # Si absence de couche dans QGIS, on vide les combobox
        if len(layer_list) == 1:
            self.dlg.comboBoxCoucheComac.clear()
            self.dlg.MajcomboBox_etude_comac.clear()
            self.alerteInfos("Votre projet ne contient aucun shape de type Polygone (etude_comac, ...)")

        else:
            # On insère les données tables dans le Combobox
            layer_list.sort()
            self.dlg.comboBoxCoucheComac.addItems(layer_list)
            self.dlg.MajcomboBox_etude_comac.addItems(layer_list)

            # On définit la valeur par défaut de la couche s'il y a un table du nom 'etude_cap_ft'
            for valeur in layer_list:
                regexp = re.compile(r'comac')
                if regexp.search(valeur.lower()):
                    self.dlg.comboBoxCoucheComac.setCurrentIndex(layer_list.index(valeur))
                    self.dlg.MajcomboBox_etude_comac.setCurrentIndex(layer_list.index(valeur))
                    break

            self.dlg.textBrowser.clear()
            self.champsColonneComac()

    def coucheCombobox_etude_cap_ft(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        # On récupère ici la liste des tables présentes dans QGIS.

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        layer_list = ['']
        self.dlg.capFtComboBox_etude_cap_ft.clear()
        self.dlg.C6BdcomboBox_etude_cap_ft.clear()
        self.dlg.MajcomboBox_etude_cap_ft.clear()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                try:
                    if QgsWkbTypes.geometryType(layer.wkbType()) in (2, 5):  # QgsWkbTypes.isSingleType(layer.wkbType()) and
                        layer_list.append(layer.name())

                except Exception as e:
                    print(f"Erreur comboboxCmd : {e}")
                    continue

        # Si absence de couche dans QGIS, on vide les combobox
        if len(layer_list) == 1:
            self.dlg.capFtComboBox_etude_cap_ft.clear()
            self.dlg.C6BdcomboBox_etude_cap_ft.clear()
            # self.dlg.capFtComboBoxChampsCapFt.clear()
            self.dlg.capFtComboBoxChampsCapFt.clear()
            self.dlg.MajcomboBox_etude_cap_ft.clear()

            self.alerteInfos("Votre projet ne contient aucun shape de type Polygone (etude_cap_ft, ...)")

        else:
            # On insère les données tables dans le Combobox
            layer_list.sort()
            self.dlg.capFtComboBox_etude_cap_ft.addItems(layer_list)
            self.dlg.C6BdcomboBox_etude_cap_ft.addItems(layer_list)
            self.dlg.MajcomboBox_etude_cap_ft.addItems(layer_list)
            # On définit la valeur par défaut de la couche s'il y a un table du nom 'etude_cap_ft'
            for valeur in layer_list:
                regexp = re.compile(r'cap_ft')
                if regexp.search(valeur.lower()):
                    self.dlg.capFtComboBox_etude_cap_ft.setCurrentIndex(layer_list.index(valeur))
                    self.dlg.C6BdcomboBox_etude_cap_ft.setCurrentIndex(layer_list.index(valeur))
                    self.dlg.MajcomboBox_etude_cap_ft.setCurrentIndex(layer_list.index(valeur))

                    break

            self.dlg.textBrowser.clear()

    def coucheComboboxC3a(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        # On récupère ici la liste des tables présentes dans QGIS.

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        layer_list = ['']

        self.dlg.comboBox_Cmd_c6_c3a_bd.clear()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                try:
                    if QgsWkbTypes.geometryType(layer.wkbType()) in (1, 4):
                        layer_list.append(layer.name())

                except Exception as e:
                    print(f"Erreur comboboxCmd : {e}")
                    continue

        # Si absence de couche dans QGIS, on vide les combobox
        if len(layer_list) == 1:
            self.dlg.comboBox_Cmd_c6_c3a_bd.clear()
            self.alerteInfos("Votre projet ne contient aucun shape de type Point (infra_pt_pot, ...)")

        else:
            # On insère les données tables dans le Combobox
            layer_list.sort()
            self.dlg.comboBox_Cmd_c6_c3a_bd.addItems(layer_list)

            # On définit la valeur par défaut de la couche s'il y a un table du nom 'etude_cap_ft'
            for valeur in layer_list:
                regexp = re.compile(r'cmd')
                if regexp.search(valeur.lower()):
                    self.dlg.comboBox_Cmd_c6_c3a_bd.setCurrentIndex(layer_list.index(valeur))
                    break

            self.dlg.textBrowser.clear()

    def coucheComboboxDecoupage(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        # On récupère ici la liste des tables présentes dans QGIS.

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        layer_list = ['']

        self.dlg.comboBox_Decoupage.clear()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                try:
                    if QgsWkbTypes.geometryType(layer.wkbType()) in (2, 5):
                        layer_list.append(layer.name())

                except Exception as e:
                    print(f"Erreur comboboxCmd : {e}")
                    continue

        # Si absence de couche dans QGIS, on vide les combobox
        if len(layer_list) == 1:
            self.dlg.comboBox_Decoupage.clear()
            self.dlg.comboBox_Dcp_champs.clear()
            self.dlg.comboBox_Dcp_Valeur_champs.clear()
            self.alerteInfos("Votre projet ne contient aucun shape de type Polygone (etude_cap_ft, ...)")

        else:
            # On insère les données tables dans le Combobox
            layer_list.sort()
            self.dlg.comboBox_Decoupage.addItems(layer_list)

            # On définit la valeur par défaut de la couche s'il y a un table du nom 'etude_cap_ft'
            for valeur in layer_list:
                regexp = re.compile(r'decoupage')
                if regexp.search(valeur.lower()):
                    self.dlg.comboBox_Decoupage.setCurrentIndex(layer_list.index(valeur))
                    break

            self.dlg.textBrowser.clear()
            # self.plc6champsDecoupage()

    ########################################### BOUTON : POLICE C6 ####################################################
    def plc6champsDecoupage(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs
        colonne associée à la table sélectionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        champs_list = ['']
        self.dlg.comboBox_Dcp_champs.clear()

        for layer in layers:
            if layer.name() == self.dlg.comboBox_Decoupage.currentText():
                for champs in layer.fields():
                    champs_list.append(str(champs.name()))

        if len(champs_list) <= 1:
            self.dlg.comboBox_Dcp_champs.clear()

        else:
            # print(f"champs_list : {champs_list}")
            # On insère des données colonnes dans le Combobox
            self.dlg.comboBox_Dcp_champs.addItems(champs_list)

            # On définit la valeur par défaut de la couche s'il y a un champs du nom de 'etude'
            regexp = re.compile(r'ref_fci')
            for valeur in champs_list:
                if regexp.search(valeur.lower()):
                    self.dlg.comboBox_Dcp_champs.setCurrentIndex(champs_list.index(valeur))
                    break

    def plc6Rafraichisement(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.plc6ComboboxCoucheDecoupage()
        self.plc6ComboboxCoucheBpe()
        self.plc6ComboboxCoucheAttaches()
        self.dlg.progressBar.setValue(0)

    def plc6CocherDecocherAucun(self):
        """Fonction pour cocher ou décocher l'interface de la phase 2"""
        ############################# ANALYSE COMAC ####################################
        if (not self.dlg.c6ComboBoxCoucheBpe.currentText() or not self.dlg.c6ComboBoxCoucheEtudes.currentText() or
            not self.dlg.c6ComboBoxCoucheAttaches.currentText() or
                not self.dlg.c6comboBoxColonneDecoupage.currentText() or
                not self.dlg.c6ComboBoxValeur.currentText() or
                not os.path.isdir(self.dlg.c6LienCheminGraceThd.text()) or
                not os.path.exists(self.dlg.C6LienCheminImportFichier.text())):
            self.dlg.c6Lanceur.setEnabled(False)

        else:
            self.dlg.c6Lanceur.setEnabled(True)

    def error(self, errorStr):
        """Fonction pour afficher des messages d'erreur"""
        # function to return error
        QMessageBox.warning(self.iface.mainWindow(), self.MSG_BOX_TITLE, str(errorStr))
        self.dlg.close()
        self.run()

    def plc6ComboboxCoucheDecoupage(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        # On récupère ici la liste des tables présentes dans QGIS.

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        layer_list = ['']

        self.dlg.c6ComboBoxCoucheEtudes.clear()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                try:
                    if QgsWkbTypes.geometryType(layer.wkbType()) in (2, 5):
                        layer_list.append(layer.name())

                except Exception as e:
                    print(f"Erreur plc6ComboboxCoucheDecoupage : {e}")
                    continue

        # Si absence de couche dans QGIS, on vide les combobox
        if len(layer_list) <= 1:
            self.dlg.c6ComboBoxCoucheEtudes.clear()
            self.dlg.c6comboBoxColonneDecoupage.clear()
            self.dlg.c6ComboBoxValeur.clear()
            self.alerteInfos("Votre projet ne contient aucune couche de type Polygone (etude_cap_ft OU decoupage...)")

        else:
            # On insère les données tables dans le Combobox
            layer_list.sort()
            self.dlg.c6ComboBoxCoucheEtudes.addItems(layer_list)

            # On définit la valeur par défaut de la couche s'il y a un table du nom 'etude_cap_ft'
            for valeur in layer_list:
                regexp = re.compile(r'cap_ft')
                regexp2 = re.compile(r'decoupa')
                if regexp.search(valeur.lower()) or regexp2.search(valeur.lower()):
                    self.dlg.c6ComboBoxCoucheEtudes.setCurrentIndex(layer_list.index(valeur))
                    break

            self.dlg.textBrowser.clear()
            self.plc6ColonneCombobox()

    def plc6ComboboxCoucheBpe(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        # On récupère ici la liste des tables présentes dans QGIS.

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        layer_list = ['']

        self.dlg.c6ComboBoxCoucheBpe.clear()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                try:
                    if QgsWkbTypes.geometryType(layer.wkbType()) in (0, 3):
                        layer_list.append(layer.name())

                except Exception as e:
                    print(f"Erreur plc6ComboboxCoucheDecoupage : {e}")
                    continue

        # Si absence de couche dans QGIS, on vide les combobox
        if len(layer_list) <= 1:
            self.dlg.c6ComboBoxCoucheBpe.clear()
            self.alerteInfos("Votre projet ne contient aucune couche de type Polygone (etude_cap_ft OU decoupage...)")

        else:
            # On insère les données tables dans le Combobox
            layer_list.sort()
            self.dlg.c6ComboBoxCoucheBpe.addItems(layer_list)

            # On définit la valeur par défaut de la couche s'il y a un table du nom 'etude_cap_ft'
            for valeur in layer_list:
                regexp = re.compile(r'bpe')
                if regexp.search(valeur.lower()):
                    self.dlg.c6ComboBoxCoucheBpe.setCurrentIndex(layer_list.index(valeur))
                    break
            self.dlg.textBrowser.clear()

    def plc6ComboboxCoucheAttaches(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        # On récupère ici la liste des tables présentes dans QGIS.

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        layer_list = ['']

        self.dlg.c6ComboBoxCoucheAttaches.clear()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                try:
                    if QgsWkbTypes.geometryType(layer.wkbType()) in (1, 4):
                        layer_list.append(layer.name())

                except Exception as e:
                    print(f"Erreur plc6ComboboxCoucheDecoupage : {e}")
                    continue

        # Si absence de couche dans QGIS, on vide les combobox
        if len(layer_list) <= 1:
            self.dlg.c6ComboBoxCoucheAttaches.clear()
            self.alerteInfos("Votre projet ne contient aucune couche de type Polygone (etude_cap_ft OU decoupage...)")

        else:
            # On insère les données tables dans le Combobox
            layer_list.sort()
            self.dlg.c6ComboBoxCoucheAttaches.addItems(layer_list)

            # On définit la valeur par défaut de la couche s'il y a un table du nom 'etude_cap_ft'
            for valeur in layer_list:
                regexp = re.compile(r'attaches')
                if regexp.search(valeur.lower()):
                    self.dlg.c6ComboBoxCoucheAttaches.setCurrentIndex(layer_list.index(valeur))
                    break
            self.dlg.textBrowser.clear()

    def choixDossierImportFichierC6(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self.dlg.progressBar.setValue(0)
        fname = QFileDialog.getOpenFileName(None, f"Veuillez sélectionner le fichier EXCEL à analyser", "",
                                            "Fichier (*.xlsx)")[0]

        # Pour changer le dossier de travail par défaut
        if os.access(fname, os.W_OK):
            self.dlg.C6LienCheminImportFichier.setText(fname)
            dossier = os.path.dirname(fname)
            os.chdir(dossier)
            return

    def plc6ChoixDossierRepertoireGraceTHD(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self.dlg.progressBar.setValue(0)
        repertoireGTHD = QFileDialog.getExistingDirectory(self.dlg,
                                                          f"Sélectionner votre repertoire d'importation des fichiers", "")
        if os.access(repertoireGTHD, os.W_OK):
            self.dlg.c6LienCheminGraceThd.setText(repertoireGTHD)
            return

    def plc6ColonneCombobox(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs associée à la table sélectionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable

        decompte = 0

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        champs_list = ['']
        self.dlg.c6comboBoxColonneDecoupage.clear()

        for layer in layers:
            if layer.name() == self.dlg.c6ComboBoxCoucheEtudes.currentText():
                decompte += 1

                for champs in layer.fields():
                    champs_list.append(str(champs.name()))

        if decompte == 0:
            self.dlg.c6comboBoxColonneDecoupage.clear()
            self.dlg.c6ComboBoxValeur.clear()

        else:
            # On insère des données colonnes dans le Combobox
            self.dlg.c6comboBoxColonneDecoupage.addItems(champs_list)

            # On définit la valeur par défaut de la couche s'il y a un champs du nom de 'etude'
            for valeur in champs_list:
                regexp = re.compile(r'etude*')
                regexp2 = re.compile(r'adress*')
                regexpRefci = re.compile(r'ref_fci')
                if (regexp.search(valeur.lower()) or regexp2.search(valeur.lower()) or
                        regexp2.search(valeur.lower()) or regexpRefci.search(valeur.lower())):
                    self.dlg.c6comboBoxColonneDecoupage.setCurrentIndex(champs_list.index(valeur))
                    break

            self.plc6ValeurCombobox()

    def plc6ValeurCombobox(self):
        """Fonction qui permet de récuperer et d'afficher les VALEURS associées au champs et à la table séléctionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable
        decompte = 0

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        valeurs_list = ['']
        self.dlg.c6ComboBoxValeur.clear()

        valeurs_unique = ""

        for layer in layers:
            if layer.name() == self.dlg.c6ComboBoxCoucheEtudes.currentText():

                # layer sera utilisé plus tard dans les autres fonctions.
                # On récupère la position du champs (colonne) nommé "etude" qui contient les noms des études
                if self.dlg.c6comboBoxColonneDecoupage.currentText():
                    idx_champs = layer.dataProvider().fields().indexFromName(self.dlg.c6comboBoxColonneDecoupage.currentText())
                    valeurs_unique = layer.dataProvider().uniqueValues(idx_champs)
                    decompte += 1

        if decompte == 0:
            self.dlg.c6ComboBoxValeur.clear()

        else:
            for i, valeur in enumerate(valeurs_unique):
                # Si la commune n'existe pas déjà, on la rajoute
                valeurs_list.append(str(valeur))

            self.dlg.c6ComboBoxValeur.addItems(sorted(valeurs_list))

    def plc6analyserGlobal(self):
        """Fonction pour parcourir les fichiers Excel pour renseigner la référence des appuis."""
        # On récupère la valeur contenue dans le combobox
        self.msgexporter = str()

        fname = self.dlg.C6LienCheminImportFichier.text()
        bpe = self.dlg.c6ComboBoxCoucheBpe.currentText()
        filterValeur = self.dlg.c6ComboBoxValeur.currentText()
        attaches = self.dlg.c6ComboBoxCoucheAttaches.currentText()

        # On vérifie que toutes les données sont déjà dans QGIS.
        liste_absent = self.police.verificationnsDonnees()

        # S'il manque de données alors...
        if liste_absent:
            alerte = f"Impossible de continuer. Les couches suivantes doivent exister dans QGIS :"
            alerte1 = ", ".join(liste_absent)
            self.alerteInfos(alerte)
            self.alerteInfos(alerte1)

            self.sc.alerteCritique(f"Les données svtes doivent n'exister dans QGIS : {alerte1}")
            raise

        self.dlg.textBrowser.clear()

        self.dlg.progressBar.setValue(5)

        # Pour récupérer le nom du fichier sans la totalité du chemin d'accès
        alerte = f"************** PRESENCE DES APPUIS ********************"
        self.alerteInfos(alerte, couleur="grey")
        self.msgexporter += alerte

        # Importations des données GraceTHD
        self.Plc6ImportationDonneesDansQgis()

        table = self.dlg.c6ComboBoxCoucheEtudes.currentText()
        colonne = self.dlg.c6comboBoxColonneDecoupage.currentText()

        # Les caractères spéciaux, accentués et apostrophes ne sont pas acceptés.
        voyelles = f"àâäéèêëîïôöùûüÿ'ÀÂÄÉÈÊËÎÏÔÖÙÛÜŸ"
        for car in voyelles:
            if car in filterValeur:
                alerte = (f"Le nom de l'étude ne doit pas contenir de caractères spéciaux, "
                          f"accentués ou apostrophes:")
                self.alerteInfos(alerte)
                self.dlg.progressBar.setValue(0)
                raise

        liste_cable_appui_OD, infNumPoteauAbsent = self.police.lireFichiers(fname, table, colonne, filterValeur, bpe, attaches)

        self.dlg.progressBar.setValue(15)

        # Suppression des couches d'erreur Si cela n'existe déjà'
        self.police.removeGroup(f"ERROR_{filterValeur}")

        self.dlg.progressBar.setValue(20)

        if self.police.nb_appui_corresp >= 1:
            appuisTrouves = f"correspondance(s) trouvé(s) :"
            # Transformation de la liste en chaîne de caractère.
            self.police.potInfNumPresent.sort()  # D'abord, on trie de la liste des appuis
            chaine = ", ".join(self.police.potInfNumPresent)

            alerte = f"{self.police.nb_appui_corresp} {appuisTrouves}\n{chaine}"
            self.alerteInfos(alerte, couleur="green")
            self.msgexporter += f"{alerte}\n"

        else:
            alerte = f"Aucune correspondance trouvée"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

        # Comparaison des données :
        # Du fichier Excel vers couche infra_pt_pot ...
        etape = f"*** Annexe C6 --> Données QGIS ***"
        self.alerteInfos(etape, couleur="grey")
        self.msgexporter += f"\n{etape}\n"

        self.dlg.progressBar.setValue(25)

        if self.police.nb_appui_absentPot >= 1:
            appuisAbsents = f"Les appuis suivants ont été trouvés dans Annexe C6 mais pas dans QGIS (infra_pt_pot) :"

            # Transformation de la liste en chaîne de caractère.
            self.police.absence.sort()  # D'abord, on trie de la liste des appuis
            chaine = ", ".join(self.police.absence)

            alerte = f"{self.police.nb_appui_absentPot} {appuisAbsents}\n{chaine}"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

        else:
            alerte = f"Tous les appuis dans C6 existent également dans infra_pt_pot"
            self.alerteInfos(alerte, couleur="green")
            self.msgexporter += f"{alerte}\n"

        # Comparaison des données :
        # De la couche infra_pt_pot vers le fichier Excel.

        # S'il y a des appuis absents

        # ... de la couche infra_pt_pot vers Annexe C6
        etape = f"*** Données QGIS  --> Annexe C6 ***"
        self.alerteInfos(etape, couleur="grey")
        self.msgexporter += f"\n{etape}\n"

        if self.police.nb_appui_absent > 0:

            poteaux = "infra_pt_pot"  # Nom de la table appui dont il faut extraire les valeurs.
            alerte = (f"appui n'existe pas dans le fichier Annexe C6 " if self.police.nb_appui_absent == 1 else
                      f" appuis n'existent pas dans le fichier Annexe C6 ")

            # chaine0 = [f"'{contenu}'" for contenu in self.police.infNumPotAbsent]

            # for contenu in self.police.infNumPotAbsent:
            #     chaine0.append(f"'{contenu}'")
            # Transformation de la liste en chaîne de caractère.
            chaineInf_num = ", ".join(infNumPoteauAbsent)
            condition = tuple(self.police.infNumPotAbsent) if len(self.police.infNumPotAbsent) > 1 else f"({self.police.infNumPotAbsent[0]})"
            # print(f"ID des erreur : {chaine}")

            # Création d'une couche erreur, si appuis présent dans infra_pt_pot mais pas dans le fichier Excel
            self.sc.createNewLayer("gid", condition, poteaux, "Point", 'manquant', filterValeur)
            alerte = f"{self.police.nb_appui_absent} {alerte}\n{chaineInf_num}"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

            alerte = f"Voir la couche : error_{poteaux}"
            self.alerteInfos(alerte, couleur="orange")
            self.msgexporter += f"{alerte}\n"

            # On appliquer le style à la couche erreur.
            self.police.appliquerstyle(f"error_{poteaux}_manquant")

        else:
            alerte = f"Tous les appuis dans infra_pt_pot sont dans Annexe C6 {filterValeur}"
            self.alerteInfos(alerte, couleur="green")
            self.msgexporter += f"{alerte}\n"

        self.dlg.progressBar.setValue(30)

        alerte = f"************** EXTREMITES CABLES - APPUIS *************"
        self.alerteInfos(alerte, couleur="grey")
        self.msgexporter += f"\n{alerte}\n"

        cable_corresp, nbre_EntiteLigne = self.police.analyseAppuiCableAppui(
            liste_cable_appui_OD, self.dlg.c6ComboBoxCoucheEtudes.currentText(), colonne, filterValeur)

        self.dlg.progressBar.setValue(60)

        # Recherche correspondances appui_cable_appui
        if cable_corresp > 0:
            alerte = f"{cable_corresp} correspondance(s) trouvé(s)"
            self.alerteInfos(alerte, couleur="green")
            self.msgexporter += f"{alerte}\n"

            alerte = f"Ligne \t  Appuis-O \t  Capa \t  Appuis-D"
            self.alerteInfos(alerte, couleur="green")
            self.msgexporter += f"{alerte}\n"

            for [ligne, origC6, capaC6, destC6] in self.police.listeCableAppuitrouve:
                # Affichage des cables_appuis qui ont trouvé
                alerte = f"{ligne}\t  {origC6}\t  {capaC6}\t  {destC6}"
                self.alerteInfos(alerte, couleur="green")
                self.msgexporter += f"{alerte}\n"

        else:
            alerte = f"Aucune correspondance"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

        self.dlg.progressBar.setValue(65)

        etape = f"*** Annexe C6 --> Données QGIS ***"
        self.alerteInfos(etape, couleur="grey")
        self.msgexporter += f"\n{etape}\n"

        total_cables_appuis = len(liste_cable_appui_OD)

        if total_cables_appuis > 0:
            alerte = f"{total_cables_appuis} liaisons (appui-capa-appui) sont présents dans Annexe C6 mais pas dans QGIS"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

            alerte = f"Ligne \t  Appuis-O \t  Capa \t  Appuis-D"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

            for [ligne, num_appui_o, extrait_capa_cab, num_appui_end, *_] in liste_cable_appui_OD:
                # ligne, num_appui_o, extrait_capa_cab, num_appui_end, pbo
                alerte = f"{ligne}\t  {num_appui_o}\t  {extrait_capa_cab}\t  {num_appui_end}"
                self.alerteInfos(alerte)
                self.msgexporter += f"{alerte}\n"
        else:
            alerte = (f"Toutes les liaisons cables-appuis dans Annexe C6 sont dans QGIS" if cable_corresp else
                      f"Aucun liaison trouvé dans Annexe C6")
            couleur = f"green" if cable_corresp else f"black"
            self.alerteInfos(alerte, couleur=couleur)
            self.msgexporter += f"{alerte}\n"

        self.dlg.progressBar.setValue(70)

        # ... de la couche infra_pt_pot vers Annexe C6
        etape = f"*** Données QGIS  --> Annexe C6 ***"
        self.alerteInfos(etape, couleur="green")
        self.msgexporter += '\n' + etape + '\n'

        self.dlg.progressBar.setValue(75)

        # S'il y a des cables-appuis absent d'Annexe C6
        if nbre_EntiteLigne:
            alerte = f"{nbre_EntiteLigne} éléments n'ont pas trouvé de correspondance avec Annexe C6"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

            alerte = f"Appuis-O \t\tCapa \tAppuis-D"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

            # On affiche les cables avec appuis absents dans QGIS
            for pt_orig, capa, pt_dest in self.police.listeAppuiCapaAppuiAbsent:
                alerte = f"{pt_orig}\t  {capa}\t  {pt_dest}"
                self.alerteInfos(alerte)
                self.msgexporter += f"{alerte}\n"

            alerte = f"Voir la couche 'error_appui_capa_appui'"
            self.alerteInfos(alerte, couleur="orange")
            self.msgexporter += f"{alerte}\n"

        else:
            alerte = f"Toutes les données QGIS sont dans Annexe C6" if cable_corresp else f"Aucun liaison dans la zone d'étude"
            couleur = f"green" if cable_corresp else f"black"
            self.alerteInfos(alerte, couleur=couleur)
            self.msgexporter += f"{alerte}\n"

        self.dlg.progressBar.setValue(80)

        alerte = f"************** PRESENCE EBP (boites) ******************"
        self.alerteInfos(alerte, couleur="grey")
        self.msgexporter += f"\n{alerte}\n"

        # Si le fichier Excel contient des appuis avec EBP

        if self.police.presence_liste_appui_ebp:
            # Nombre des correspondances trouvés pour les appui-pbo
            if self.police.nb_pbo_corresp > 0:
                alerte = f"{self.police.nb_pbo_corresp} correspondance(s) trouvé(s)"
                self.alerteInfos(alerte, couleur="green")
                self.msgexporter += f"\n{alerte}\n"

                alerte = f"Appuis \tType de boîtes (C7)"
                self.alerteInfos(alerte, couleur="green")
                self.msgexporter += f"\n{alerte}\n"

                for [_, num_appui_o, pbo] in self.police.bpo_corresp:
                    # ligne, num_appui_o, pbo
                    alerte = f"{num_appui_o} \t{pbo}"
                    self.alerteInfos(alerte, couleur="green")
                    self.msgexporter += f"{alerte}\n\n"

            else:
                alerte = f"Aucune correspondance"
                self.alerteInfos(alerte)
                self.msgexporter += f"{alerte}\n"

        # Si le fichier Excel ne contient pas d'appuis avec EBP
        else:
            alerte = f"Annexe C7 ne contient pas d'appui avec EBP"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

        self.dlg.progressBar.setValue(90)

        # Du fichier Excel vers couche infra_pt_pot ...
        etape = f"*** Annexe C6 --> Données QGIS ***"
        self.alerteInfos(etape, couleur="grey")
        self.msgexporter += etape + '\n'

        total_ebp_appui_absent = len(self.police.liste_appui_ebp)
        if total_ebp_appui_absent > 0:
            # S'il y a d'un seul Appui-EBP qui manque ...
            if total_ebp_appui_absent == 1:
                alerte = f"{total_ebp_appui_absent} appui avec boîte est absent de la BD :"
                self.alerteInfos(alerte)
                self.msgexporter += f"{alerte}\n"
            # ... Sinon plusieurs Appuis-EBP
            else:
                alerte = f"{total_ebp_appui_absent} appuis avec boîtes sont absents de BD :"
                self.alerteInfos(alerte)
                self.msgexporter += f"{alerte}\n"

            alerte = f"Ligne \tAppui \tBoite"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

            for [ligne, num_appui_o, pbo] in self.police.liste_appui_ebp:
                alerte = f"{ligne}\t{num_appui_o} \t{pbo}"
                self.alerteInfos(alerte)
                self.msgexporter += f"{alerte}\n\n"

        # S'il y a des appuis avec EBP dans Annexe C6 et que tous ces appuis correspondent avec ceux de QGIS alors ...
        if self.police.presence_liste_appui_ebp and total_ebp_appui_absent == 0:
            alerte = f"Tous les appuis avec EBP dans Annexe C6 sont dans QGIS"
            self.alerteInfos(alerte, couleur="green")
            self.msgexporter += f"{alerte}\n"

        if not self.police.presence_liste_appui_ebp:
            alerte = f"Aucun"
            self.alerteInfos(alerte, couleur="orange")
            self.msgexporter += f"{alerte}\n"

        # ... de la couche infra_pt_pot vers Annexe C6
        etape = f"*** Données QGIS  --> Annexe C6 ***"
        self.alerteInfos(etape, couleur="grey")
        self.msgexporter += f"\n{etape}\n"

        # S'il y a des ebp qui n'ont pas intersecté d'appui
        if self.police.ebp_non_appui:
            # bpe = "bpe"  # Nom de la table dont il faut extraire les valeurs.

            # chaine = ", ".join(self.police.ebp_non_appui)
            condition = tuple(self.police.ebp_non_appui) if len(self.police.ebp_non_appui) > 1 else f"({self.police.ebp_non_appui[0]})"
            # print(f"BPE PAS INTER : {chaine} \n gid : {self.police.fied_id_Ebp}")
            # Création d'une nouvelle couche BPE lorsqu'il n'y a aucune intersection avec CABLE
            self.sc.createNewLayer(self.police.fied_id_Ebp, condition, bpe, "Point", "pas_intersect", filterValeur)

            # On appliquer le style à la couche erreur.
            self.police.appliquerstyle(f"error_{bpe}_pas_intersect")

        self.dlg.progressBar.setValue(95)

        # Si des appuis avec EBP existent dans QGIS mais pas dans Annexe C6
        if self.police.ebp_appui_inconnu:
            appui_bpe = "infra_pt_pot"
            # num_appui = []

            # Un seul
            alerte = f"{len(self.police.ebp_appui_inconnu)} "
            alerte += ("appui avec boîte est absent d'Annexe C6 : " if len(self.police.ebp_appui_inconnu) == 1 else
                       "appuis avec EBP sont absents d'Annexe C6 : ")

            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

            alerte = f"Appuis \t \tBoîtes"
            self.alerteInfos(alerte)
            self.msgexporter += f"{alerte}\n"

            listeBpeAppuiGidAbsent = []
            for [gid, inf_num, noe_type] in self.police.ebp_appui_inconnu:
                # num_appui.append(f"'{inf_num}'")
                listeBpeAppuiGidAbsent.append(gid)
                # Affichage des appuis avec leur EBP
                alerte = f"{inf_num} \t{noe_type}"
                self.alerteInfos(alerte)
                self.msgexporter += f"{alerte}\n"

            # Affichage des appuis avec leur EBP
            alerte = f"Voir la couche 'error_infra_pot_EBP'"
            self.alerteInfos(alerte, couleur="orange")
            self.msgexporter += f"{alerte}\n"

            # chaine = ", ".join(num_appui)

            condition = tuple(listeBpeAppuiGidAbsent) if len(listeBpeAppuiGidAbsent) > 1 else f"({listeBpeAppuiGidAbsent[0]})"
            self.sc.createNewLayer('gid', condition, appui_bpe, "Point", "ebp", filterValeur)

            # On appliquer le style à la couche erreur.
            self.police.appliquerstyle(f"error_{appui_bpe}_ebp")

        # Si Tous les EBP avec appui dans QGIS sont dans Annexe C6
        if not self.police.ebp_appui_inconnu and self.police.bpe_pot_cap_ft:
            etape = f"Tous les EBP avec appuis dans QGIS sont dans Annexe C6"
            self.alerteInfos(etape, couleur="green")
            self.msgexporter += f"{etape}\n"

        # Si aucun EBP avec appui dans QGIS
        if not self.police.ebp_appui_inconnu and not self.police.bpe_pot_cap_ft:
            etape = f"Aucun EBP dans cette zone d'étude"
            self.alerteInfos(etape, couleur="black")
            self.msgexporter += f"{etape}\n"

        # Suppression des couches de groupe des données GraceTHD
        self.police.removeGroup(f"GRACETHD")

        etape = f"Fin de l'execution du programme"
        self.alerteInfos(etape, couleur="grey")
        self.msgexporter += etape
        self.dlg.progressBar.setValue(100)

    def Plc6ImportationDonneesDansQgis(self):
        """On teste si les fichiers souhaités existent à l'emplacement indiqué.
        Le programme s'arrête si l'un des fichiers n'existe pas"""
        # Liste des données à importer
        listeCoucheSHP = ["t_cheminement", "t_cableline", "t_noeud"]
        # fichierGraceThd = ["t_cheminement.shp", "t_cableline.shp", "t_noeud.shp", "t_ptech.csv", "t_cable.csv"]
        manque = []
        verif = True

        repertoireGTHD = self.dlg.c6LienCheminGraceThd.text()

        # Données Géographiques
        for shp in listeCoucheSHP:
            try:
                # Importation des couches géographiques
                self.police.ajouterCoucherShp(f"{repertoireGTHD}/{shp}")
                # self.insertLayerInGroupGraceTHD(couchereturn)

            except os.error:
                # self.error(f"Erreur lors de l'importation de la couche suivante: " + shp)
                manque.append(shp)
                verif = False

            if not self.police.coucheShp.isValid():
                manque.append(shp)
                verif = False

        liste_absent = self.police.ajouterCoucherCsv(f"{repertoireGTHD}")
        if liste_absent:
            alerte = f"Les dossiers GRACETHD indiqués ne contient pas les fichiers suivants :\n{liste_absent}"
            self.alerteInfos(alerte, False, "red")
            self.msgexporter = alerte
            # Suppression des couches de groupe des données GraceTHD
            self.police.removeGroup(f"GRACETHD")
            self.dlg.progressBar.setValue(0)
            raise

        # Données tabulaires
        # try:
        #     # Importation des tables cvs
        #     # os.stat(repertoireGTHD + "/" + csv + ".csv")
        #     self.police.lectureFichierGraceTHD_t_cable(f"{repertoireGTHD}/t_cable.csv")
        #
        #     # self.police.lectureFichierGraceTHD_t_ptech(f"{repertoireGTHD}/t_ptech.csv")
        #     # self.police.lectureFichierGraceTHD_ebp(repertoireGTHD + "/" + 't_ebp')
        #
        # except Exception as e:
        #     # self.error(f"Le fichier " + csv + f" n'existe pas à l'emplacement indiqué")
        #     print(f"Une erreur Plc6ImportationDonneesDansQgis :\n{e}")
        #     manque.append("t_cable.csv")
        #     manque.append("t_ptech.csv")
        #     verif = False

        if not verif:
            # On liste les données manquantes
            message4 = f"Les données suivantes sont introuvables dans le dossier GraceTHD indiqué "
            self.sc.alerteCritique(message4 + str(manque), 10)
            self.dlg.textBrowser.setTextColor(QColor("red"))
            self.dlg.textBrowser.append(message4 + str(manque) + '\n')
            self.dlg.textBrowser.setTextColor(QColor("orange"))
            self.dlg.textBrowser.append(f"Votre repertoire GraceTHD  doit ogligatoirement contenir les données svtes : ")
            raise

    ########################################### FIN #####################################################
    def valeurChampsDecoupage(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs associée à la table sélectionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable
        # layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        self.dlg.comboBox_Dcp_Valeur_champs.clear()

        decoupage = self.dlg.comboBox_Decoupage.currentText()
        champs = self.dlg.comboBox_Dcp_champs.currentText()

        if decoupage and champs:
            layer = QgsProject.instance().mapLayersByName(decoupage)[0]
            idx_ref_fci = layer.dataProvider().fields().indexFromName(champs)
            ref_fci = list(layer.dataProvider().uniqueValues(idx_ref_fci))
            try:
                if ref_fci:
                    # ref_fci.insert(0, '')
                    # On insère des données colonnes dans le Combobox
                    self.dlg.comboBox_Dcp_Valeur_champs.addItems(ref_fci)

                else:
                    self.dlg.comboBox_Dcp_Valeur_champs.clear()

            except Exception as e:
                print(f"Erreur valeurChampsDecoupage : \n{e}")
                self.dlg.comboBox_Dcp_Valeur_champs.clear()
        else:
            self.dlg.comboBox_Dcp_Valeur_champs.clear()

    def analyserFichiersCapFt(self):
        """Fonction pour parcourir les fichiers Excel pour renseigner la référence des appuis."""
        # On récupère la valeur contenue dans le combobox
        self.msgexporter = str()

        start_time = time.time()  # Horaire du début d'execution du programme
        self.dlg.textBrowser.clear()

        self.dlg.progressBar.setValue(5)

        tb_infra_pt_pot = self.dlg.capFtComboBoxCoucheInfra_pt_pot.currentText()
        tb_etude_cap_ft = self.dlg.capFtComboBox_etude_cap_ft.currentText()
        tb_etude_cap_ft_colonne = self.dlg.capFtComboBoxChampsCapFt.currentText()

        cheminCap_ft = self.dlg.lienRepertoireCapFt.text()
        cheminExportExcel = self.dlg.lienCheminExportCapFt.text()

        ########################## Vérifications des données d'entrée ##################################
        if not os.path.isdir(cheminCap_ft):
            self.alerteInfos(f"Veuillez choisir le chemin contenant les fichiers Excels des ETUDES CAF_FT")
            self.dlg.lienRepertoireCapFt.setStyleSheet("""QLineEdit {background-color: orange; }""")
            self.dlg.progressBar.setValue(0)
            raise

        if not os.path.isdir(cheminExportExcel):
            self.alerteInfos(f"Veuillez choisir le chemin d'exportation du fichier à générer")
            self.dlg.lienCheminExportCapFt.setStyleSheet("""QLineEdit {background-color: orange; }""")
            self.dlg.progressBar.setValue(0)
            raise

        # dicoEtudeCapFTPoteauQgis = self.cap.verificationsDonneesCapft(tb_infra_pt_pot, tb_etude_cap_ft, tb_etude_cap_ft_colonne)
        doublonsNomEtudesCapFt,  pot_ft_hors_etude = self.cap.verificationsDonneesCapft(tb_infra_pt_pot, tb_etude_cap_ft, tb_etude_cap_ft_colonne)

        # doublonsNomEtudesCapFt = dicoEtudeCapFTPoteauQgis[0]
        # pot_ft_hors_etude = dicoEtudeCapFTPoteauQgis[1]

        self.dlg.progressBar.setValue(10)

        ################ ERREURS MAJEURS ##########################
        if doublonsNomEtudesCapFt:
            alerte = "Deux ou plusieurs études portent le nom même\n:" + str(doublonsNomEtudesCapFt)
            self.alerteInfos(alerte, False, "red")
            self.msgexporter = alerte
            self.dlg.progressBar.setValue(0)
            raise

        ################ ERREURS MINEURS ##########################
        if pot_ft_hors_etude:
            alerte = "Des poteaux FT qui n'intersectent aucun découpage des études CAP-FT:\n" + str(pot_ft_hors_etude)
            self.alerteInfos(alerte, False, "orange")
            self.msgexporter = alerte + "\n"
            self.dlg.progressBar.setValue(0)
            raise

        #################### ETUDE QGIS ###############################
        dicoEtudeCapFtPoteauQgis = self.cap.liste_poteau_cap_ft(tb_infra_pt_pot, tb_etude_cap_ft, tb_etude_cap_ft_colonne)
        self.dlg.progressBar.setValue(40)

        #################### EXCEL SOUS-TRAITANT ###############################
        dicoPoteauFt_SousTraitant = self.cap.LectureFichiersExcelsCap_ft(cheminCap_ft)

        if not dicoPoteauFt_SousTraitant:
            alerte = "ATTENTION : Aucun 'Fiches_Appuis....xlsx' n'a été trouvé dans le chemin indiqué"
            self.alerteInfos(alerte, False, "red")
            self.msgexporter += f"{alerte}\n"

        if not dicoEtudeCapFtPoteauQgis:
            alerte = f"ATTENTION : Aucun POT-FT n'a été trouvé dans le shape : {tb_infra_pt_pot}"
            self.alerteInfos(alerte, False, "red")
            self.msgexporter += f"{alerte}\n"
            self.dlg.progressBar.setValue(100)

        # if dicoPoteauFt_SousTraitant:
        self.dlg.progressBar.setValue(50)

        #################### TRAITEMENTS DES DONNEES ###############################
        resultatsFinaux = self.cap.traitementResultatFinauxCapFt(dicoEtudeCapFtPoteauQgis, dicoPoteauFt_SousTraitant)
        self.dlg.progressBar.setValue(60)

        # #################### EXPORT RESULTATS FINAl DANS UN EXCEL ###############################
        dateDuJour = str(datetime.datetime.now().strftime("%d-%m-%Y_%H_%M"))
        nomfichierExportAnalyse = f"{cheminExportExcel}{os.sep}ANALYSE_CAP_FT_{dateDuJour}.xlsx"
        self.cap.ecrireResultatsAnalyseExcelsCapFt(resultatsFinaux, nomfichierExportAnalyse)
        self.dlg.progressBar.setValue(60)

        ############### AFFICHAGES DES ERREURS DANS l'interfaces QGIS  ###############################
        ##### PRESENCE DANS UN EXCEL, MAIS ABSENT DE QGIS #################
        dicoPotFt_Excel_Introuvable = resultatsFinaux[0]
        self.dlg.progressBar.setValue(70)

        if dicoPotFt_Excel_Introuvable:
            # Pour récupérer le nom du fichier sans la totalité du chemin d'accès
            alerte = f"******* PRESENCE DANS LES FICHES APPUIS, MAIS ABSENT DE QGIS  *******"
            self.alerteInfos(alerte, False, "grey")
            self.msgexporter = f"{alerte}\n"
            self.dlg.progressBar.setValue(80)

            for excel, listesDesAppuisSous_traitant in dicoPotFt_Excel_Introuvable.items():
                for appuis in listesDesAppuisSous_traitant:
                    alerte = f"{appuis} dans le fichier : {excel}"
                    self.alerteInfos(alerte, False, "orange")
                    self.msgexporter += alerte + "\n"

            self.dlg.textBrowser.append('\n')
            self.msgexporter += "\n\n"

            self.dlg.progressBar.setValue(90)
        ############ PRESENCE QGIS, MAIS ABSENT LES EXCELS #############
        dicoEtudeCapFtPotQgisIntrouvable = resultatsFinaux[1]
        if dicoEtudeCapFtPotQgisIntrouvable:

            # Pour récupérer le nom du fichier sans la totalité du chemin d'accès
            alerte = f"******* PRESENCE QGIS, MAIS ABSENT DES FICHES APPUIS  *******"
            self.alerteInfos(alerte, False, "grey")
            self.msgexporter += f"{alerte}\n"
            self.dlg.progressBar.setValue(95)

            for excel, listesDesAppuisSous_traitant in dicoEtudeCapFtPotQgisIntrouvable.items():
                for appuis in listesDesAppuisSous_traitant:
                    alerte = f"{appuis} dans l'étude : {excel}"
                    self.alerteInfos(alerte, False, "orange")
                    self.msgexporter += f"{alerte}\n"

        self.dlg.boutonCheminExport.setEnabled(True)

        if not dicoPotFt_Excel_Introuvable and not dicoEtudeCapFtPotQgisIntrouvable:
            etape = f"Vos données correspondent parfaitement, Aucune erreur n'a été trouvée"
            self.alerteInfos(etape, False, "green")
            self.msgexporter += f"\n{etape}\n"

        etape = f"Le fichier d'analyse a bien été généré dans le chemin ci dessous :\n{nomfichierExportAnalyse}"
        self.alerteInfos(etape, False, "green")
        self.msgexporter += f"\n{etape}\n"

        etape = f"Fin de l'exécution du programme en {self.sc.tempsEcouler(time.time() - start_time)}"
        self.alerteInfos(etape, False, "grey")
        self.msgexporter += f"\n{etape}"
        self.dlg.progressBar.setValue(100)

    def analyserFichiersComac(self):
        """Fonction pour parcourir les fichiers Excel pour renseigner la référence des appuis."""
        # On récupère la valeur contenue dans le combobox
        self.msgexporter = str()

        start_time = time.time()  # Horaire du début d'execution du programme

        self.dlg.textBrowser.clear()

        self.dlg.progressBar.setValue(5)

        tb_infra_pt_pot = self.dlg.comacComboBoxCoucheInfra_pt_pot.currentText()
        tb_etude_comac = self.dlg.comboBoxCoucheComac.currentText()
        tb_etude_comac_colonne = self.dlg.comboBoxChampsComac.currentText()

        cheminComac = self.dlg.lienRepertoireComac.text()
        cheminExportExcel = self.dlg.lienCheminExportComac.text()

        ########################## Vérifications des données d'entrée ##################################

        if not os.path.isdir(cheminComac):
            self.alerteInfos(f"Veuillez choisir le chemin contenant les fichiers Excels des ETUDES COMAC")
            self.dlg.lienRepertoireComac.setStyleSheet("""QLineEdit {background-color: orange; }""")
            self.dlg.progressBar.setValue(0)
            raise

        if not os.path.isdir(cheminExportExcel):
            self.alerteInfos(f"Veuillez choisir le chemin d'exportation du fichier à générer")
            self.dlg.lienCheminExportComac.setStyleSheet("""QLineEdit {background-color: orange; }""")
            self.dlg.progressBar.setValue(0)
            raise

        dicoEtudeComacPoteauQgis = self.com.verificationsDonneesComac(tb_infra_pt_pot, tb_etude_comac, tb_etude_comac_colonne)

        doublonsNomEtudesComac = dicoEtudeComacPoteauQgis[0]
        pot_bt_hors_etude = dicoEtudeComacPoteauQgis[1]
        self.dlg.progressBar.setValue(10)

        ################ ERREURS MAJEURS ##########################
        if doublonsNomEtudesComac:
            alerte = f"Deux ou plusieurs études portent le nom même\n:{doublonsNomEtudesComac}"
            self.alerteInfos(alerte, couleur="red")
            self.msgexporter = alerte
            self.dlg.progressBar.setValue(0)
            raise

        ################ ERREURS MINEURS ##########################
        if pot_bt_hors_etude:
            alerte = f"Des poteaux BT qui n'intersectent aucun découpage des études COMAC:\n{pot_bt_hors_etude}"
            self.alerteInfos(alerte, False, "orange")
            self.msgexporter = alerte + "\n"
            self.dlg.progressBar.setValue(0)
            raise

        #################### ETUDE QGIS ###############################
        dicoEtudeComacPoteauQgis = self.com.liste_poteau_comac(tb_infra_pt_pot, tb_etude_comac, tb_etude_comac_colonne)
        self.dlg.progressBar.setValue(40)

        #################### EXCEL SOUS-TRAITANT ###############################
        dicoPoteauBt_SousTraitant = self.com.LectureFichiersExcelsComac(cheminComac)

        fichiersComacEnDoublons = dicoPoteauBt_SousTraitant[0]
        impossibiliteDelireFichier = dicoPoteauBt_SousTraitant[1]

        if fichiersComacEnDoublons:
            erreurs = (f"ERREURS : les fichiers ci-dessous existent en doublon\n"
                       f"Veuillez corriger ses erreurs avant de rélancer le programme")
            self.alerteInfos(erreurs)
            self.msgexporter = erreurs + "\n"

            for fichier in fichiersComacEnDoublons:
                self.alerteInfos(str(fichier), False, "orange")
                self.msgexporter += f"{fichier}\n"
            self.dlg.progressBar.setValue(0)

        elif impossibiliteDelireFichier:
            erreurs = (f"L'ERREUR ci-dessous a été générée\n"
                       f"Assurez-vous de bien fermer ce fichier avant de rélancer le programme")
            self.alerteInfos(erreurs)
            self.msgexporter = erreurs + "\n"

            for fichier, typeErreur in impossibiliteDelireFichier.items():
                erreurs = f"fichier : {fichier}:\nErreur : {typeErreur}"
                self.alerteInfos(str(erreurs))
                self.msgexporter = erreurs + "\n"
                self.msgexporter += f"{erreurs}\n"
                self.dlg.progressBar.setValue(0)

        else:
            dicoPoteauBt_St = dicoPoteauBt_SousTraitant[2]

            if not dicoPoteauBt_St:
                alerte = "ATTENTION : Aucun fichier '...ExportComac.xlsx' n'a été trouvé dans le chemin indiqué"
                self.alerteInfos(alerte, False, "red")
                self.msgexporter += f"{alerte}\n"

            if not dicoEtudeComacPoteauQgis:
                alerte = f"ATTENTION : Aucun POT-BT n'a été trouvé dans le shape : {tb_infra_pt_pot}"
                self.alerteInfos(alerte, False, "red")
                self.msgexporter += f"{alerte}\n"

            self.dlg.progressBar.setValue(50)

            #################### TRAITEMENTS DES DONNEES ###############################
            resultatsFinaux = self.com.traitementResultatFinaux(dicoEtudeComacPoteauQgis, dicoPoteauBt_St)
            self.dlg.progressBar.setValue(60)

            # #################### EXPORT RESULTATS FINAl DANS UN EXCEL ###############################
            dateDuJour = str(datetime.datetime.now().strftime("%d-%m-%Y_%H_%M"))
            nomfichierExportAnalyse = f"{cheminExportExcel}{os.sep}ANALYSE_COMAC_{dateDuJour}.xlsx"
            self.com.ecrireResultatsAnalyseExcels(resultatsFinaux, nomfichierExportAnalyse)
            self.dlg.progressBar.setValue(60)

            ############### AFFICHAGES DES ERREURS DANS l'interfaces QGIS  ###############################
            ##### PRESENCE DANS UN EXCEL, MAIS ABSENT DE QGIS #################
            dicoPotBt_Excel_Introuvable = resultatsFinaux[0]
            self.dlg.progressBar.setValue(70)

            if dicoPotBt_Excel_Introuvable:
                # Pour récupérer le nom du fichier sans la totalité du chemin d'accès
                alerte = f"******* PRESENCE DANS EXCEL, MAIS ABSENT DE QGIS  *******"
                self.alerteInfos(alerte, False, "grey")
                self.msgexporter = alerte + "\n"
                self.dlg.progressBar.setValue(80)

                for excel, listesDesAppuisSous_traitant in dicoPotBt_Excel_Introuvable.items():
                    for appuis in listesDesAppuisSous_traitant:
                        alerte = appuis + " dans le fichier : " + excel
                        self.alerteInfos(alerte, False, "orange")
                        self.msgexporter += f"{alerte}\n"

                self.dlg.textBrowser.append('\n')
                self.msgexporter += "\n\n"

                self.dlg.progressBar.setValue(90)
            ############ PRESENCE QGIS, MAIS ABSENT LES EXCELS #############
            dicoEtudeComacPotQgisIntrouvable = resultatsFinaux[1]
            if dicoEtudeComacPotQgisIntrouvable:

                # Pour récupérer le nom du fichier sans la totalité du chemin d'accès
                alerte = f"******* PRESENCE QGIS, MAIS ABSENT DES EXCELS  *******"
                self.alerteInfos(alerte, False, "grey")
                self.msgexporter += alerte + "\n"
                self.dlg.progressBar.setValue(95)

                for excel, listesDesAppuisSous_traitant in dicoEtudeComacPotQgisIntrouvable.items():
                    for appuis in listesDesAppuisSous_traitant:
                        alerte = f"{appuis} dans l'étude : {excel}"
                        self.alerteInfos(alerte, False, "orange")
                        self.msgexporter += f"{alerte}\n"

            if not dicoPotBt_Excel_Introuvable and not dicoEtudeComacPotQgisIntrouvable:
                etape = f"Vos données correspondent parfaitement, Aucune erreur n'a été trouvée"
                self.alerteInfos(etape, False, "green")
                self.msgexporter += f"\n{etape}\n"

            self.dlg.boutonCheminExport.setEnabled(True)

            etape = f"Le fichier d'analyse a bien été généré dans le chemin ci dessous :\n{nomfichierExportAnalyse}"
            self.alerteInfos(etape, False, "green")
            self.msgexporter += f"\n{etape}\n"

            etape = f"Fin de l'exécution du programme en {self.sc.tempsEcouler(time.time() - start_time)}"
            self.alerteInfos(etape, False, "grey")
            self.msgexporter += f"\n{etape}"
            self.dlg.progressBar.setValue(100)

    def comparaisonC6BaseDonnees(self):
        """Comparer les données C6 par rapport à la base de données"""
        self.dlg.C6BdLanceur.setEnabled(False)

        self.dlg.progressBar.setValue(5)
        self.dlg.textBrowser.clear()

        start_time = time.time()  # Horaire du début d'execution du programme

        repertoire_c6 = self.dlg.lienCheminFichiersC6.text()

        tb_infra_pt_pot = self.dlg.C6BdcomboBox_infra_pt_pot.currentText()
        tb_etude_cap_t = self.dlg.C6BdcomboBox_etude_cap_ft.currentText()
        tb_etude_cap_ft_colonne = self.dlg.C6BdcomboBoxChampsCapFt.currentText()

        df = pd.DataFrame(columns=["N° appui", "Nature des travaux", "Études"], dtype="float64")
        df1 = self.c6bd.LectureFichiersExcelsC6(df, repertoire_c6)
        self.dlg.progressBar.setValue(40)

        df2 = self.c6bd.liste_poteau_cap_ft(tb_infra_pt_pot, tb_etude_cap_t, tb_etude_cap_ft_colonne)

        # # # print(tabulate(df1, headers='keys', tablefmt='psql'))
        final_df = pd.merge(df1, df2, on=['N° appui', 'Nature des travaux', 'Études'], how='outer')
        # final_df = pd.merge(df1, df2, on=['N° appui'], how='outer')
        remplacement = {"inf_num (QGIS)": "ABSENT", "Excel": "ABSENT"}
        final_df.fillna(value=remplacement, inplace=True)

        self.dlg.progressBar.setValue(70)

        cheminExportExcel = self.dlg.lienCheminExportDonnees.text()

        dateDuJour = str(datetime.datetime.now().strftime("%d-%m-%Y_%H_%M"))
        nomfichierExportAnalyse = f"{cheminExportExcel}{os.sep}ANALYSE_C6_BD_{dateDuJour}.xlsx"
        nbre_erreurs = self.c6bd.ecrictureExcel(final_df, nomfichierExportAnalyse)

        if not nbre_erreurs:
            etape = f"Vos données correspondent parfaitement, Aucune erreur n'a été trouvée"
            self.alerteInfos(etape, False, "green")

        else:
            etape = (f"{nbre_erreurs} erreur(s) ont été trouvées dans les données. "
                     f"\nVeuillez en prendre connaissance dans le fichier Excel")
            self.alerteInfos(etape, False, "red")

        self.dlg.progressBar.setValue(90)

        etape = f"Le fichier d'analyse a bien été généré dans le chemin ci dessous :\n{nomfichierExportAnalyse}"
        self.alerteInfos(etape, False, "green")

        etape = f"Fin de l'exécution du programme en {self.sc.tempsEcouler(time.time() - start_time)}"
        self.alerteInfos(etape, False, "grey")
        self.dlg.C6BdLanceur.setEnabled(False)

        self.dlg.progressBar.setValue(100)

    def comparaisonC6C3aBd(self):
        """Comparer les données C6 par rapport à la base de données"""

        self.dlg.c6_c3a_bdLanceur.setEnabled(False)

        self.dlg.progressBar.setValue(5)
        self.dlg.textBrowser.clear()

        start_time = time.time()  # Horaire du début d'execution du programme

        fichier_c6 = self.dlg.lienCheminC6_c6_c3a_bd.text()
        fichier_c7 = self.dlg.lienCheminC7_c6_c3a_bd.text()

        tb_infra_pt_pot = self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.currentText()
        tb_cmd = self.dlg.comboBox_Cmd_c6_c3a_bd.currentText()
        tb_decoupage = self.dlg.comboBox_Decoupage.currentText()
        champs_dcp = self.dlg.comboBox_Dcp_champs.currentText()
        valeur_champs_dcp = self.dlg.comboBox_Dcp_Valeur_champs.currentText()

        self.dlg.progressBar.setValue(10)

        df = pd.DataFrame(columns=["N° appui", "Nature des travaux"], dtype="float64")
        df_c6_excel, df_c6_excel_rempl = self.c6c3aBd.LectureFichiersExcelsC6(df, fichier_c6)
        #print(f"df_c6_excel :\n")
        #print(tabulate(df_c6_excel, headers='keys', tablefmt='psql'))

        self.dlg.progressBar.setValue(40)

        df_bd, df_bd_rempl = self.c6c3aBd.liste_poteau_etudes(tb_infra_pt_pot, tb_decoupage, champs_dcp, valeur_champs_dcp)
        # print(f"df_bd :\n")
        # print(tabulate(df_bd, headers='keys', tablefmt='psql'))

        if self.dlg.radioButtonQgis.isChecked():
            df_c3a, df_c3a_rempl = self.c6c3aBd.liste_poteau_c3a_qgis(tb_cmd, tb_decoupage, champs_dcp, valeur_champs_dcp)

        else:
            fichier_c3a = self.dlg.lienCheminC3A_c6_c3a_bd.text()
            df_c3a, df_c3a_rempl = self.c6c3aBd.liste_poteau_c3a_excel(fichier_c3a)

        self.dlg.progressBar.setValue(60)

        # Récupération du contenu du fichier C7
        df_c7 = self.c6c3aBd.lectureFichierC7(fichier_c7)
        
        
        # print(tabulate(df_c3a, headers='keys', tablefmt='psql'))
        if df_c6_excel.empty or df_bd.empty or df_c3a.empty:
            if df_c6_excel.empty:
                self.alerteInfos(f"Aucune donnnée n'a été trouvé dans le fichier C6 séléctionné\n"
                                      f"Assurez-vous que c'est le bon fichier et qu'il n'est pas corrompu",
                                      couleur="red")

            if df_bd.empty:
                self.alerteInfos(f"Aucune donnnée n'a été trouvé dans les données QGIS", False, "red")

            if df_c3a.empty:
                self.alerteInfos(f"Aucune donnnée n'a été trouvé dans C3A séléctionné\n"
                                      f"Assurez-vous que c'est le bon fichier et qu'il n'est pas corrompu",
                                      couleur="red")
            self.dlg.progressBar.setValue(0)

        else:

            ################################## SANS C7 ############################################
            dfs = [df_bd, df_c3a, df_c6_excel]
            df_final = reduce(lambda left, right: pd.merge(left, right, on=["N° appui", "Nature des travaux"],
                                                           how='outer'), dfs)
            # Si la valeur du champs est vide, on remplace par le mode ABSENT
            remplacement = {"inf_num (ETUDES_QGIS)": "ABSENT", "Excel (C6)": "ABSENT", "inf_num (C3A)": "ABSENT"}

            df_final.fillna(value=remplacement, inplace=True)

            self.dlg.progressBar.setValue(70)
            cheminExportExcel = self.dlg.lienCheminExportDonnees_c6_c3a_bd.text()

            dateDuJour = str(datetime.datetime.now().strftime("%d-%m-%Y_%H_%M"))
            nomfichierExportAnalyse = f"{cheminExportExcel}{os.sep}ANALYSE_C6_C3A_BD_{dateDuJour}.xlsx"
            nbre_erreurs = self.c6c3aBd.ecrictureExcel(df_final, nomfichierExportAnalyse)

            etape = f"Le fichier d'analyse a bien été généré dans le chemin ci dessous :\n{cheminExportExcel}"
            self.alerteInfos(etape, couleur="green")

            etape = f"############### COMPARAISON C6 vs C3A vs BD ###############"
            self.alerteInfos(etape, couleur="grey")

            if not nbre_erreurs:
                etape = f"Vos données correspondent parfaitement, Aucune erreur n'a été trouvée"
                self.alerteInfos(etape, couleur="green")

            else:
                name = os.path.basename(nomfichierExportAnalyse)
                etape = (f"{nbre_erreurs} erreur(s) ont été trouvées dans les données. "
                         f"\nVeuillez en prendre connaissance dans le fichier Excel\n{name}")
                self.alerteInfos(etape, couleur="red")

            ################################## AVEC C7 ############################################
            dfs_rempl = [df_bd_rempl, df_c3a_rempl, df_c6_excel_rempl, df_c7]

            df_final_rempl = reduce(lambda left, right: pd.merge(left, right, on=["N° appui"], how='outer'), dfs_rempl)

            remplacement = {"inf_num (ETUDES_QGIS)": "ABSENT", "Excel (C6)": "ABSENT", "inf_num (C3A)": "ABSENT",
                            "Fichier (C7) Excel": "ABSENT"}

            df_final_rempl.fillna(value=remplacement, inplace=True)

            dateDuJour_4 = str(datetime.datetime.now().strftime("%d-%m-%Y_%H_%M"))
            nomfichierExportAnalyse_4 = f"{cheminExportExcel}{os.sep}ANALYSE_C6_C7_C3A_BD_{dateDuJour_4}.xlsx"
            nbre_erreurs_4 = self.c6c3aBd.ecrictureExcelC6C7C3aBd(df_final_rempl, nomfichierExportAnalyse_4)

            etape = f"############ REMPLACEMENT : COMPARAISON C6 vs C7 vs C3A vs BD ############"
            self.alerteInfos(etape, couleur="grey")

            if not nbre_erreurs_4:
                etape = f"Vos données correspondent parfaitement, Aucune erreur n'a été trouvée"
                self.alerteInfos(etape, couleur="green")

            else:
                name = os.path.basename(nomfichierExportAnalyse_4)

                etape = (f"{nbre_erreurs_4} erreur(s) ont été trouvées dans les données. "
                         f"\nVeuillez en prendre connaissance dans le fichier Excel\n{name}")
                self.alerteInfos(etape, couleur="red")

            self.dlg.progressBar.setValue(90)

            ##################################################################################################
            etape = f"Fin de l'exécution du programme en {self.sc.tempsEcouler(time.time() - start_time)}"
            self.alerteInfos(etape, couleur="grey")
            self.dlg.c6_c3a_bdLanceur.setEnabled(False)

            self.dlg.progressBar.setValue(100)

    def majDesDonnneesFtBt(self):
        """Mise à jour de la table infra_pt_pot des donnes FT et BT """
        self.dlg.textBrowser.clear()
        self.dlg.progressBar.setValue(0)

        fichier_Excel = self.dlg.MajlienCheminFichierExcel.text()

        excel_df_ft, excel_df_bt = self.maj.LectureFichiersExcelsFtBtKo(fichier_Excel)

        tb_infra_pt_pot = self.dlg.MajcomboBox_infra_pt_pot.currentText()
        tb_etude_comac = self.dlg.MajcomboBox_etude_comac.currentText()
        tb_etude_cap_ft = self.dlg.MajcomboBox_etude_cap_ft.currentText()

        bd_df_ft, bd_df_bt = self.maj.liste_poteau_etudes(tb_infra_pt_pot, tb_etude_cap_ft, tb_etude_comac)

        liste_ft, liste_bt = self.maj.comparerLesDonnees(excel_df_ft, excel_df_bt, bd_df_ft, bd_df_bt)

        tt_valeur_introuvable_ft, liste_valeur_introuvbl_ft, tt_valeur_trouve_ft, liste_valeur_trouve_ft = liste_ft

        tt_valeur_introuvable_bt, liste_valeur_introuvbl_bt, tt_valeur_trouve_bt, liste_valeur_trouve_bt = liste_bt

        # print(f"liste_valeur_trouve_ft :\n", tabulate(liste_valeur_trouve_ft, headers="keys", tablefmt="psql"))
        # print(f"resultat trouve :\n", tabulate(liste_valeur_trouve_bt, headers="keys", tablefmt="psql"))

        # self.alerteInfos(tabulate(liste_valeur_introuvbl_ft, headers="keys", tablefmt="psql"), False, "red")
        # self.alerteInfos(tabulate(liste_valeur_introuvbl_bt, headers="keys", tablefmt="psql"), False, "red")

        if tt_valeur_introuvable_ft or tt_valeur_introuvable_bt:
            etape = f"Attention les valeurs suivantes sont introuvables dans la base de données"
            self.alerteInfos(etape, couleur="grey")
            if tt_valeur_introuvable_ft > 0:
                self.alerteInfos("FT", couleur="grey")
                self.alerteInfos(tabulate(liste_valeur_introuvbl_ft, headers="keys", tablefmt="psql"), False, "red")

            if tt_valeur_introuvable_bt > 0:
                self.alerteInfos("BT", couleur="grey")
                self.alerteInfos(tabulate(liste_valeur_introuvbl_bt, headers="keys", tablefmt="psql"), False, "red")

        if tt_valeur_trouve_ft == 0 and tt_valeur_trouve_ft == 0:
            etape = f"Aucune correspondance n'a été trouvé avec la base de données"
            self.alerteInfos(etape, couleur="grey")

        else:
            if tt_valeur_trouve_ft > 0:
                etape = f"{tt_valeur_trouve_ft} MAJ ont été trouvés pour les poteaux FT"
                self.alerteInfos(etape, couleur="grey")
            else:
                etape = f"Aucune MAJ n'a été trouvé pour les poteaux FT"
                self.alerteInfos(etape, couleur="grey")

            if tt_valeur_trouve_bt > 0:
                etape = f"{tt_valeur_trouve_bt} MAJ ont été trouvés pour les poteaux BT"
                self.alerteInfos(etape, couleur="grey")
            else:
                etape = f"Aucune MAJ n'a été trouvé pour les poteaux BT"
                self.alerteInfos(etape, couleur="grey")

            label_text = (f"ATTENTION : cette action est irréversible. Etes-vous sûr de vouloir mettre à jour "
                          f"toutes les données de la table")

            nePasSupprimer = QInputDialog.getItem(None, 'MISES A JOUR DES DONNEES infra_pt_pot', label_text,
                                                  ["J'ABANDONNE les MISES A JOUR", 'JE CONFIRME Les MISES A JOUR'])

            transferer = nePasSupprimer[0]
            if transferer == 'JE CONFIRME Les MISES A JOUR':
                if tt_valeur_trouve_ft > 0:
                    # MAJ DES données dans la base
                    self.maj.miseAjourFinalDesDonnees("infra_pt_pot", liste_valeur_trouve_ft)
                    etape = f"{tt_valeur_trouve_ft} entités suivantes ont été mise à jour pour les poteaux FT"
                    self.alerteInfos(etape, couleur="green")
                    self.alerteInfos(tabulate(liste_valeur_trouve_ft, headers="keys", tablefmt="psql"), False, "green")

                if tt_valeur_trouve_bt > 0:
                    # MAJ DES données dans la base
                    self.maj.miseAjourFinalDesDonnees("infra_pt_pot", liste_valeur_trouve_bt)

                    etape = f"{tt_valeur_trouve_bt} entités suivantes ont été mise à jour pour les poteaux BT"
                    self.alerteInfos(etape, couleur="green")
                    self.alerteInfos(tabulate(liste_valeur_trouve_bt, headers="keys", tablefmt="psql"), False, "green")

                self.alerteInfos("NB : les FT KO et les étiquettes jaunes ne sont traités.", couleur="grey")

                self.alerteInfos("FIN", couleur="grey")
                self.dlg.progressBar.setValue(100)

            else:
                self.dlg.progressBar.setValue(0)