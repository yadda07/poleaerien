
# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PoleAerien
                                 A QGIS plugin
 Controle de donner comac
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2022-2026 by NGE ES
        email                : contact@nge-es.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QTimer
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QInputDialog, QApplication
import sip
from qgis.core import QgsProject, QgsMapLayer, QgsWkbTypes, QgsMapLayerProxyModel, QgsMessageLog, Qgis, QgsVectorLayer
from qgis.gui import QgsMapLayerComboBox
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
# from .Cap_Comac_dialog import CapComacDialog
from .Pole_Aerien_dialog import PoleAerienDialog
import os.path
import re
import glob
import datetime
import time
import pandas as pd
import sqlite3
# import numpy as np
# from openpyxl.styles import PatternFill
from . import Initialisation
from .aboutdialog import PoleAerienAboutDialog
from .SecondFile import SecondFile
from .workflows.maj_workflow import MajWorkflow
from .workflows.comac_workflow import ComacWorkflow
from .workflows.capft_workflow import CapFtWorkflow
from .workflows.c6bd_workflow import C6BdWorkflow
from .workflows.c6c3a_workflow import C6C3AWorkflow
from .workflows.police_workflow import PoliceWorkflow
from qgis.core import QgsApplication
from .qgis_utils import (
    get_layer_fields,
    get_layers_by_geometry,
    find_default_layer_index,
    set_default_layer_for_combobox,
    normalize_appui_num,
)
from .ui_state import UIStateController
from .log_manager import get_log_manager
import copy

"""
pyrcc5 resources.qrc -o resources.py
ou lks

python -m PyQt5.pyrcc_main resource.qrc -o resource_rc.py
pyuic5 Cap_Comac_dialog_base.ui -o ../Cap_Comac_dialog_base.py
pyuic5 PoleAerien_dialog_base.ui -o ../Pole_Aerien_dialog_base.py
python -m PyQt5.pyuic5_main PoleAerien_dialog_base.ui -o PoleAerien_dialog_base.py
pyuic5 PoleAerien_apropos.ui -o ../PoleAerien_apropos.py
conda install spyder=5.3.3
"""


class PoleAerien:
    """QGIS Plugin Implementation."""
    MSG_BOX_TITLE = "Plugin d'analyse des données Pôle Aérien"

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(self.plugin_dir, 'i18n', f'PoleAerien_{locale}.qm')

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Fonction pour déplacer l'icone de plugin
        self.toolbar = self.iface.addToolBar(u'&Pôle Aérien')
        self.toolbar.setObjectName(u'&Pôle Aérien')

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Pôle Aérien')

        # self.dlg = CapComacDialog()
        self.dlg = PoleAerienDialog()
        self.ui_state = UIStateController(self.dlg)
        
        # LogManager for value-added info (complements existing logs)
        self._log = get_log_manager()
        self._log.set_browser(self.dlg.textBrowser)
        
        self.sc = SecondFile()
        self.maj_workflow = MajWorkflow()
        
        # Connexion des signaux du workflow
        self.maj_workflow.progress_changed.connect(self._onMajProgress)
        self.maj_workflow.message_received.connect(self._onMajMessage)
        self.maj_workflow.analysis_finished.connect(self._onMajFinished)
        self.maj_workflow.analysis_error.connect(self._onMajError)
        # CRITICAL-001 FIX: Signaux pour MAJ BD asynchrone
        self.maj_workflow.update_finished.connect(self._onMajUpdateFinished)
        self.maj_workflow.update_error.connect(self._onMajUpdateError)
        
        self.comac_workflow = ComacWorkflow()
        self.comac_workflow.progress_changed.connect(self._onComacProgress)
        self.comac_workflow.message_received.connect(self._onComacMessage)
        self.comac_workflow.analysis_finished.connect(self._onComacAnalysisFinished)
        self.comac_workflow.export_finished.connect(self._onComacExportFinished)
        self.comac_workflow.error_occurred.connect(self._onComacError)

        self.capft_workflow = CapFtWorkflow()
        self.capft_workflow.progress_changed.connect(self._onCapFtProgress)
        self.capft_workflow.message_received.connect(self._onCapFtMessage)
        self.capft_workflow.analysis_finished.connect(self._onCapFtAnalysisFinished)
        self.capft_workflow.export_finished.connect(self._onCapFtExportFinished)
        self.capft_workflow.error_occurred.connect(self._onCapFtError)

        self.c6bd_workflow = C6BdWorkflow()
        self.c6bd_workflow.progress_changed.connect(self._onC6BdProgress)
        self.c6bd_workflow.message_received.connect(self._onC6BdMessage)
        self.c6bd_workflow.analysis_finished.connect(self._onC6BdAnalysisFinished)
        self.c6bd_workflow.export_finished.connect(self._onC6BdExportFinished)
        self.c6bd_workflow.error_occurred.connect(self._onC6BdError)

        self.police_workflow = PoliceWorkflow()
        self.police_workflow.progress_changed.connect(self._onPoliceProgress)
        self.police_workflow.message_received.connect(self._onPoliceMessage)
        self.police_workflow.analysis_finished.connect(self._onPoliceAnalysisFinished)
        self.police_workflow.error_occurred.connect(self._onPoliceError)

        self.c6c3a_workflow = C6C3AWorkflow()
        self.c6c3a_workflow.progress_changed.connect(self._onC6C3AProgress)
        self.c6c3a_workflow.message_received.connect(self._onC6C3AMessage)
        self.c6c3a_workflow.analysis_finished.connect(self._onC6C3AAnalysisFinished)
        self.c6c3a_workflow.export_finished.connect(self._onC6C3AExportFinished)
        self.c6c3a_workflow.error_occurred.connect(self._onC6C3AError)

        self.init = Initialisation()

        # tb_cmd = "cmd"
        # tb_decoupage = "decoupage"
        # champs_decoupage = "ref_fci"
        # valeur_champs_dcp = "DI_1"

        # Bouton d'aide ouvre la documentation web
        self.dlg.helpButton.clicked.connect(self.openDocumentation)
        self._reset_msgexporter()

        self._plc6_sqlite_is_valid = False

        self._ui_msg_queue = []
        self._ui_msg_timer = QTimer(self.dlg)
        self._ui_msg_timer.setInterval(50)
        self._ui_msg_timer.timeout.connect(self._flush_alerte_queue)
        ################################## MAJ #########################################
        self.dlg.majBdLanceur.clicked.connect(self.majDesDonnneesFtBt)
        self.dlg.store_original_slot('majBdLanceur', self.majDesDonnneesFtBt)

        ################################## VERIF CAP_FT  #########################################
        # Sélection du repertoire où sera stocké les fichiers
        self.dlg.boutonCheminEtudeCapFt.clicked.connect(self.cheminDossierRepertoireCapFT)
        # select directory where save files
        self.dlg.boutonCheminExportCapFt.clicked.connect(self.cheminDossierExportAnalyse)

        # Valeurs des études servant à l'analyse.
        # Valeurs des colonnes
        self.dlg.capFtComboBox_etude_cap_ft.currentTextChanged.connect(self.champsColonneCapFt)
        self.dlg.capFtComboBox_etude_cap_ft.layerChanged.connect(self.champsColonneCapFt)

        # Action associé au bouton principal pour lancer l'analyse du fichier
        self.dlg.cap_ftLanceur.clicked.connect(self.analyserFichiersCapFt)
        self.dlg.store_original_slot('cap_ftLanceur', self.analyserFichiersCapFt)

        self.dlg.boutonCheminExport.clicked.connect(self.repertoireFichierTxtMessage)
        self.dlg.exporter.clicked.connect(self.exporterFichierTxt)

        # Bouton cocher permettant de rendre fonction l'exécution du code
        # (Aucun, uniquement les entités séléctionnées, ou tous

        ################################## VERIF COMAC  #########################################
        # Action associé au bouton principal pour lancer l'analyse du fichier
        self.dlg.cap_comacLanceur.clicked.connect(self.analyserFichiersComac)
        self.dlg.store_original_slot('cap_comacLanceur', self.analyserFichiersComac)

        self.dlg.comboBoxCoucheComac.currentTextChanged.connect(self.champsColonneComac)

        self.dlg.boutonCheminExportComac.clicked.connect(self.cheminDossierExportAnalyse)

        self.dlg.boutonCheminEtudeComac.clicked.connect(self.cheminDossierRepertoireComac)

        ########### COMPARER C6 des données de la BD  #########################################
        self.dlg.C6BdLanceur.clicked.connect(self.comparaisonC6BaseDonnees)
        self.dlg.store_original_slot('C6BdLanceur', self.comparaisonC6BaseDonnees)

        self.dlg.C6BdboutonCheminFichiersC6.clicked.connect(self.cheminDossierRepertoireC6)
        self.dlg.C6BdboutonCheminExportDonnees.clicked.connect(self.cheminDossierExportAnalyse)
        ########### COMPARER C6, C3A, C6 et C7 en même temps #########################################

        # df = pd.DataFrame(columns=["N° appui", "Nature des travaux", "Études"], dtype="float64")
        #
        # self.c6c3aBd.LectureFichiersExcelsC6(df, "")
        self.dlg.comboBox_Decoupage.currentTextChanged.connect(self.valeurChampsDecoupage)
        self.dlg.comboBox_Decoupage.currentTextChanged.connect(self.plc6champsDecoupage)

        self.dlg.comboBox_Dcp_champs.currentTextChanged.connect(self.valeurChampsDecoupage)

        self.dlg.c6_c3a_bdLanceur.clicked.connect(self.comparaisonC6C3aBd)
        self.dlg.store_original_slot('c6_c3a_bdLanceur', self.comparaisonC6C3aBd)

        # self.dlg.boutonCheminFichiersC6.clicked.connect(self.cheminDossierRepertoireC6)
        self.dlg.boutonCheminExportDonnees_c6_c3a_bd.clicked.connect(self.cheminDossierExportAnalyse)

        self.dlg.boutonCheminC6_c6_c3a_bd.clicked.connect(self.fichierC6)
        self.dlg.boutonCheminC3A_c6_c3a_bd.clicked.connect(self.fichierC3A)
        self.dlg.boutonCheminC7_c6_c3a_bd.clicked.connect(self.fichierC7)

        self.dlg.radioButtonQgis.clicked.connect(self.QgisOuExcelC3A)
        self.dlg.radioButtonExcel.clicked.connect(self.QgisOuExcelC3A)
        ########################## POLICE C6 #########################################
        # Fonction utilisée lorsqu'on clic sur le bouton associe au fichier de comparaisonPP
        self.dlg.c6BoutonCheminImport.clicked.connect(self.choixDossierImportFichierC6)

        # GraceTHD: sélection manuelle du répertoire
        self.dlg.boutonCheminGraceThd.clicked.connect(self.plc6ChoixDossierRepertoireGraceTHD)

        if hasattr(self.dlg, 'c6BoutonCheminSqlite'):
            self.dlg.c6BoutonCheminSqlite.clicked.connect(self.plc6ChoixFichierSqlite)
        if hasattr(self.dlg, 'c6BoutonCheminComac'):
            self.dlg.c6BoutonCheminComac.clicked.connect(self.plc6ChoixDossierRepertoireComac)

        if hasattr(self.dlg, 'c6LienCheminSqlite'):
            self.dlg.c6LienCheminSqlite.textChanged.connect(self.plc6ValiderFichierSqlite)
            self.dlg.c6LienCheminSqlite.textChanged.connect(self.plc6CocherDecocherAucun)
        if hasattr(self.dlg, 'c6LienCheminComac'):
            self.dlg.c6LienCheminComac.textChanged.connect(self.plc6CocherDecocherAucun)
        if hasattr(self.dlg, 'c6ComboBoxZoneDecoupage'):
            self.dlg.c6ComboBoxZoneDecoupage.layerChanged.connect(self.plc6CocherDecocherAucun)

        # Action associé au bouton principal pour lancer l'analyse du fichier
        self.dlg.c6Lanceur.clicked.connect(self.plc6analyserGlobal)
        self.dlg.store_original_slot('c6Lanceur', self.plc6analyserGlobal)

        self.dlg.exporter.clicked.connect(self.exporterFichierTxt)
        # Autre manière de faire
        # self.dlg.exporter.clicked.connect(self.exporterFichierTxt(self.msgexporter))

        # Valeurs des études servant à l'analyse.
        # Valeurs des colonnes
        self.dlg.c6ComboBoxCoucheEtudes.currentTextChanged.connect(self.plc6ColonneCombobox)

        # Colonnes
        self.dlg.c6comboBoxColonneDecoupage.currentTextChanged.connect(self.plc6ValeurCombobox)
        self.dlg.c6ComboBoxCoucheBpe.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6ComboBoxCoucheAttaches.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6ComboBoxCoucheEtudes.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6comboBoxColonneDecoupage.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6ComboBoxValeur.currentTextChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.c6ComboBoxValeur.currentTextChanged.connect(self.plc6AutoDetectFichierC6)
        # GraceTHD: validation du chemin sélectionné
        self.dlg.c6LienCheminGraceThd.textChanged.connect(self.plc6CocherDecocherAucun)
        self.dlg.C6LienCheminImportFichier.textChanged.connect(self.plc6CocherDecocherAucun)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PoleAerien', message)

    def add_action( self, icon_path, text, callback, enabled_flag=True, add_to_menu=True,
                    add_to_toolbar=True, status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.svg') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            # self.iface.addToolBarIcon(action)

            # Fonction pour déplacer l'icone de plugin
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/PoleAerien/images/icon.svg'

        self.add_action(
            icon_path,
            text=self.tr(u'Pôle Aérien'),
            callback=self.run,
            parent=self.iface.mainWindow())

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        try:
            # Clear task references WITH sip.isdeleted() checks
            # QgsTask ownership belongs to QgsTaskManager - objects may be deleted
            for attr in ('capft_task', 'comac_task', 'c6bd_task', 'maj_task'):
                if hasattr(self, attr):
                    task = getattr(self, attr)
                    # Vérifier si l'objet n'est pas déjà supprimé par Qt/SIP
                    if task is not None and not sip.isdeleted(task):
                        # Objet encore valide, on peut le référencer
                        pass
                    setattr(self, attr, None)
            
            # Cleanup dialog resources
            if hasattr(self, 'dlg') and self.dlg:
                try:
                    self.dlg.cleanup()
                    self.dlg.close()
                except Exception as e:
                    QgsMessageLog.logMessage(
                        f"PoleAerien.unload: cleanup echoue (cause: {e}) (contexte: unload plugin)",
                        "PoleAerien",
                        Qgis.Warning,
                    )
            
            # Cleanup log manager
            from .log_manager import cleanup_log_manager
            cleanup_log_manager()
            
            # Remove menu and toolbar
            for action in self.actions:
                self.iface.removePluginMenu(
                    self.tr(u'&Pôle Aérien'),
                    action)
                self.iface.removeToolBarIcon(action)

            # Suppression de l'icone de plugin
            del self.toolbar

        except Exception as e:
            QgsMessageLog.logMessage(
                f"PoleAerien.unload: exception non geree (cause: {e}) (contexte: unload plugin)",
                "PoleAerien",
                Qgis.Warning,
            )

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        # Filtres QgsMapLayerComboBox configurés dans Pole_Aerien_dialog.py
        
        # Onglet 4 - Police C6 : Init QComboBox normaux
        self.plc6ComboboxCoucheBpe()
        self.plc6ComboboxCoucheAttaches()
        self.plc6ComboboxCoucheDecoupage()
        
        # Onglet 5 - C6 vs C3A vs BD vs C7 : Init QComboBox normaux
        self.rafraichisementC6C3aBd()
        
        # show the dialog
        self.dlg.show()
        
        # Init couches par défaut après show (délai augmenté pour onglets cachés)
        QTimer.singleShot(150, self._init_default_layers)
        
        # Connect validation signals for auto-enable/disable
        self.ui_state.connect_validation_signals()

        self._refresh_validation_states()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def _init_default_layers(self):
        """Initialise les couches par défaut dans les QgsMapLayerComboBox."""
        # Force refresh modèle pour onglets non visibles (1, 2, 3)
        hidden_combos = [
            self.dlg.C6BdcomboBox_infra_pt_pot,
            self.dlg.C6BdcomboBox_etude_cap_ft,
            self.dlg.capFtComboBoxCoucheInfra_pt_pot,
            self.dlg.capFtComboBox_etude_cap_ft,
            self.dlg.comacComboBoxCoucheInfra_pt_pot,
            self.dlg.comboBoxCoucheComac,
        ]
        for cb in hidden_combos:
            cb.setFilters(QgsMapLayerProxyModel.HasGeometry)
        
        # Chercher couches depuis le combobox de l'onglet 0
        infra_layer = None
        capft_layer = None
        comac_layer = None
        
        for i in range(self.dlg.MajcomboBox_infra_pt_pot.count()):
            layer = self.dlg.MajcomboBox_infra_pt_pot.layer(i)
            if layer and 'infra_pt_pot' in layer.name().lower():
                infra_layer = layer
                break
        
        for i in range(self.dlg.MajcomboBox_etude_cap_ft.count()):
            layer = self.dlg.MajcomboBox_etude_cap_ft.layer(i)
            if layer and ('cap_ft' in layer.name().lower() or 'capft' in layer.name().lower()):
                capft_layer = layer
                break
        
        for i in range(self.dlg.MajcomboBox_etude_comac.count()):
            layer = self.dlg.MajcomboBox_etude_comac.layer(i)
            if layer and 'comac' in layer.name().lower():
                comac_layer = layer
                break
        
        # Appliquer aux combobox
        if infra_layer:
            self.dlg.MajcomboBox_infra_pt_pot.setLayer(infra_layer)
            self.dlg.C6BdcomboBox_infra_pt_pot.setLayer(infra_layer)
            self.dlg.capFtComboBoxCoucheInfra_pt_pot.setLayer(infra_layer)
            self.dlg.comacComboBoxCoucheInfra_pt_pot.setLayer(infra_layer)
        
        if capft_layer:
            self.dlg.MajcomboBox_etude_cap_ft.setLayer(capft_layer)
            self.dlg.C6BdcomboBox_etude_cap_ft.setLayer(capft_layer)
            self.dlg.capFtComboBox_etude_cap_ft.setLayer(capft_layer)
            self.champsColonneCapFt()
        
        if comac_layer:
            self.dlg.MajcomboBox_etude_comac.setLayer(comac_layer)
            self.dlg.comboBoxCoucheComac.setLayer(comac_layer)
        
        self._refresh_validation_states()

    def helpAbout(self):
        # set the version

        self.aboutDlg = PoleAerienAboutDialog()

        # add version to the label
        self.aboutDlg.uiAbout.version_n.setText(self.init.version())

        self.aboutDlg.uiAbout.autors_name.setText(self.init.authorName())

        # show dialog
        self.aboutDlg.show()

    def _refresh_validation_states(self):
        """Rafraîchit l'état des boutons d'action."""
        self.ui_state.validate_prerequisites_maj()
        self.ui_state.validate_prerequisites_c6bd()
        self.ui_state.validate_prerequisites_capft()
        self.ui_state.validate_prerequisites_comac()
        self.ui_state.validate_prerequisites_c6_c3a_bd()
        self.plc6CocherDecocherAucun()

    def _dlg_alive(self):
        """Vérifie que le dialog est valide."""
        try:
            return self.dlg is not None and not sip.isdeleted(self.dlg)
        except RuntimeError:
            return False

    def _reset_msgexporter(self):
        """Réinitialise le buffer d'export."""
        self.msgexporter = ""

    def _ensure_msgexporter(self):
        """Assure la cohérence du buffer d'export."""
        if self.msgexporter is None:
            self.msgexporter = ""
        else:
            self.msgexporter = str(self.msgexporter)

    def openDocumentation(self):
        """Ouvre la documentation web du plugin."""
        import webbrowser
        doc_path = os.path.join(self.plugin_dir, 'docs', 'index.html')
        if os.path.exists(doc_path):
            webbrowser.open(f'file:///{doc_path}')
        else:
            # Fallback sur architecture.md
            arch_path = os.path.join(self.plugin_dir, 'docs', 'architecture.md')
            if os.path.exists(arch_path):
                webbrowser.open(f'file:///{arch_path}')

    def alerteInfos(self, message, efface=False, couleur="red"):
        """Fonction pour afficher des messages d'alerte dans la barre d'info"""
        if efface:
            self.dlg.textBrowser.clear()

        self._ui_msg_queue.append((str(message), str(couleur)))
        if not self._ui_msg_timer.isActive():
            self._ui_msg_timer.start()

    def _flush_alerte_queue(self):
        """Flush buffered UI logs (avoid UI freezes)."""
        if not self._ui_msg_queue:
            self._ui_msg_timer.stop()
            return

        # Limiter la quantité traitée par tick pour conserver une UI fluide
        batch = self._ui_msg_queue[:100]
        del self._ui_msg_queue[:100]

        last_color = None
        buffer = []

        for msg, color in batch:
            if last_color is None:
                last_color = color

            if color != last_color:
                if buffer:
                    self.dlg.textBrowser.setTextColor(QColor(last_color))
                    self.dlg.textBrowser.append("\n".join(buffer) + "\n")
                buffer = [msg]
                last_color = color
            else:
                buffer.append(msg)

        if buffer:
            self.dlg.textBrowser.setTextColor(QColor(last_color or "black"))
            self.dlg.textBrowser.append("\n".join(buffer) + "\n")

        if not self._ui_msg_queue:
            self._ui_msg_timer.stop()

    def QgisOuExcelC3A(self):
        """Pour rendre l'interface interactive si l'utilisation souhaite utilisée QGIS ou s'il souhaite utilisé les
        données C3A au format Excel"""
        if self.dlg.radioButtonQgis.isChecked():
            self.dlg.comboBox_Cmd_c6_c3a_bd.setEnabled(True)
            self.dlg.boutonCheminC3A_c6_c3a_bd.setEnabled(False)

            self.dlg.comboBox_Cmd_c6_c3a_bd.setStyleSheet("background-color: #a1d99b; color: #000")
            self.dlg.boutonCheminC3A_c6_c3a_bd.setStyleSheet("background-color: #f1eef6; color: #000")

        else:
            self.dlg.comboBox_Cmd_c6_c3a_bd.setStyleSheet("background-color: #f1eef6; color: #000")
            self.dlg.boutonCheminC3A_c6_c3a_bd.setStyleSheet("background-color: #a1d99b; color: #000")

            self.dlg.comboBox_Cmd_c6_c3a_bd.setEnabled(False)
            self.dlg.boutonCheminC3A_c6_c3a_bd.setEnabled(True)

    def _validate_prerequisites(self, conditions, button, extra_check=None):
        """Valide les prérequis et active/désactive le bouton.
        
        Args:
            conditions: Liste de conditions booléennes à vérifier
            button: QPushButton à activer/désactiver
            extra_check: Fonction optionnelle pour validation supplémentaire
        
        Returns:
            bool: True si tous les prérequis sont valides
        """
        valid = all(conditions)
        if valid and extra_check:
            valid = extra_check()
        button.setEnabled(valid)
        return valid

    def cocherDecocherAucunMaj(self, *args):
        """Validation des champs MAJ BD."""
        _ = args  # Signal args unused
        conditions = [
            self.dlg.MajcomboBox_infra_pt_pot.currentLayer() is not None,
            self.dlg.MajcomboBox_etude_cap_ft.currentLayer() is not None,
            self.dlg.MajcomboBox_etude_comac.currentLayer() is not None,
            bool(self.dlg.MajFileWidget.filePath()),
            os.path.isfile(self.dlg.MajFileWidget.filePath() or '')
        ]
        self._validate_prerequisites(conditions, self.dlg.majBdLanceur)

    def cocherDecocherAucun(self):
        """Validation des champs CAP_FT et COMAC."""
        # COMAC
        comac_conditions = [
            bool(self.dlg.comacComboBoxCoucheInfra_pt_pot.currentText()),
            os.path.isdir(self.dlg.lienRepertoireComac.text() or ''),
            os.path.isdir(self.dlg.lienCheminExportComac.text() or ''),
            bool(self.dlg.comboBoxCoucheComac.currentText()),
            bool(self.dlg.comboBoxChampsComac.currentText())
        ]
        self._validate_prerequisites(comac_conditions, self.dlg.cap_comacLanceur)

        # CAP_FT
        capft_conditions = [
            bool(self.dlg.capFtComboBoxCoucheInfra_pt_pot.currentText()),
            bool(self.dlg.capFtComboBox_etude_cap_ft.currentText()),
            bool(self.dlg.capFtComboBoxChampsCapFt.currentText()),
            os.path.isdir(self.dlg.lienRepertoireCapFt.text() or ''),
            os.path.isdir(self.dlg.lienCheminExportCapFt.text() or '')
        ]
        self._validate_prerequisites(capft_conditions, self.dlg.cap_ftLanceur)

    def cocherDecocherAucunC6Bd(self):
        """Validation des champs C6 vs BD."""
        conditions = [
            bool(self.dlg.C6BdcomboBox_infra_pt_pot.currentText()),
            bool(self.dlg.C6BdcomboBox_etude_cap_ft.currentText()),
            os.path.isdir(self.dlg.lienCheminFichiersC6.text() or ''),
            os.path.isdir(self.dlg.lienCheminExportDonnees.text() or '')
        ]
        
        def extra_check():
            return self.dlg.C6BdcomboBox_infra_pt_pot.currentText() != self.dlg.C6BdcomboBox_etude_cap_ft.currentText()
        
        self._validate_prerequisites(conditions, self.dlg.C6BdLanceur, extra_check)

    def cocherDecocherAucunC6C7C3aBd(self):
        """Validation des champs C6-C3A-C7-BD."""
        conditions = [
            bool(self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.currentText()),
            bool(self.dlg.comboBox_Decoupage.currentText()),
            bool(self.dlg.comboBox_Dcp_champs.currentText()),
            bool(self.dlg.comboBox_Dcp_Valeur_champs.currentText()),
            os.path.exists(self.dlg.lienCheminC6_c6_c3a_bd.text() or ''),
            os.path.exists(self.dlg.lienCheminC7_c6_c3a_bd.text() or ''),
            os.path.isdir(self.dlg.lienCheminExportDonnees_c6_c3a_bd.text() or '')
        ]
        
        def extra_check():
            if self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.currentText() == self.dlg.comboBox_Decoupage.currentText():
                return False
            if self.dlg.radioButtonQgis.isChecked() and not self.dlg.comboBox_Cmd_c6_c3a_bd.currentText():
                return False
            if self.dlg.radioButtonExcel.isChecked() and not os.path.exists(self.dlg.lienCheminC3A_c6_c3a_bd.text() or ''):
                return False
            return True
        
        self._validate_prerequisites(conditions, self.dlg.c6_c3a_bdLanceur, extra_check)

    def _select_file(self, title, widget, use_file_path=False):
        """Helper pour sélectionner un fichier Excel.
        
        Args:
            title: Titre du dialogue
            widget: Widget cible (QLineEdit ou QgsFileWidget)
            use_file_path: True si widget a setFilePath(), False pour setText()
        """
        self.dlg.smooth_progress.reset()
        fname = QFileDialog.getOpenFileName(None, title, "", "Fichier (*.xlsx)")[0]
        if fname and os.access(fname, os.W_OK):
            if use_file_path:
                widget.setFilePath(fname)
            else:
                widget.setText(fname)
            os.chdir(os.path.dirname(fname))

    def _select_directory(self, title, widgets):
        """Helper pour sélectionner un répertoire.
        
        Args:
            title: Titre du dialogue
            widgets: Liste de QLineEdit à remplir
        """
        self.dlg.smooth_progress.reset()
        repertoire = QFileDialog.getExistingDirectory(self.dlg, title, "")
        if repertoire and os.access(repertoire, os.W_OK):
            for w in widgets:
                w.setText(repertoire)
                w.setStyleSheet("""QLineEdit {background-color: white; }""")

    def cheminDossierRepertoireMaj(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self._select_file("Veuillez sélectionner le fichier EXCEL FT BT KO", self.dlg.MajFileWidget, use_file_path=True)

    def cheminDossierRepertoireComac(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self._select_directory("Sélectionner le répertoire contenant les fichiers COMAC", [self.dlg.lienRepertoireComac])

    def cheminDossierRepertoireCapFT(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self._select_directory("Sélectionner le répertoire contenant les fichiers CAP_FT", [self.dlg.lienRepertoireCapFt])

    def cheminDossierRepertoireC6(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self._select_directory("Sélectionner le répertoire contenant les fichiers C6", [self.dlg.lienCheminFichiersC6])

    def cheminDossierExportAnalyse(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self._select_directory(
            "Sélectionner le répertoire d'export de l'analyse",
            [
                self.dlg.lienCheminExportComac,
                self.dlg.lienCheminExportDonnees,
                self.dlg.lienCheminExportDonnees_c6_c3a_bd,
                self.dlg.lienCheminExportCapFt
            ]
        )

    def repertoireFichierTxtMessage(self):
        """ Exporter le fichier txt contenant les messages affichés après execution du code."""
        self.dlg.smooth_progress.reset()

        fichier_analyse = QFileDialog.getSaveFileName(self.dlg, f"Exporter des données d'ANALYSE ", "", '*.txt')
        repertoireTxtAnalyse = fichier_analyse[0]
        self.dlg.lienCheminExport.setText(repertoireTxtAnalyse)
        self.dlg.exporter.setEnabled(True)

    def exporterFichierTxt(self):
        """Exporte les messages d'analyse vers un fichier texte."""
        self.dlg.smooth_progress.reset()

        self._ensure_msgexporter()

        repertoireTxtAnalyse = self.dlg.lienCheminExport.text()
        if not repertoireTxtAnalyse:
            self.alerteInfos("Chemin d'export non défini")
            return

        if not self.msgexporter:
            self.alerteInfos("Rien n'est disponible pour le fichier")
            return

        try:
            with open(repertoireTxtAnalyse, 'w', encoding='utf-8') as output_file:
                output_file.write(self.msgexporter)
            self.sc.alerteInfo("Le fichier d'analyse a bien été exporté")
        except OSError as e:
            self.alerteInfos(f"Erreur écriture fichier: {e}")

    def fichierC6(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self._select_file("Veuillez sélectionner le fichier EXCEL C6", self.dlg.lienCheminC6_c6_c3a_bd)

    def fichierC3A(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self._select_file("Veuillez sélectionner le fichier EXCEL C3A", self.dlg.lienCheminC3A_c6_c3a_bd)

    def fichierC7(self):
        """Fonction pour choisir le fichier qui doit être analysé"""
        self._select_file("Veuillez sélectionner le fichier EXCEL C7", self.dlg.lienCheminC7_c6_c3a_bd)

    def _populate_fields_combobox(self, source_combobox, target_combobox, pattern=r'etudes*'):
        """Helper pour peupler un combobox avec les champs d'une couche.
        
        Args:
            source_combobox: Combobox contenant le nom de la couche
            target_combobox: Combobox à remplir avec les champs
            pattern: Pattern regex pour sélection par défaut
        """
        target_combobox.clear()

        if isinstance(source_combobox, QgsMapLayerComboBox):
            layer = source_combobox.currentLayer()
            if not layer or not layer.isValid():
                return
            champs_list = [''] + [str(ch.name()) for ch in layer.fields()]
            idx = 0
            if len(champs_list) > 1:
                regexp = re.compile(pattern, re.IGNORECASE)
                for i, valeur in enumerate(champs_list):
                    if regexp.search(valeur.lower()):
                        idx = i
                        break
        else:
            layer_name = source_combobox.currentText()
            champs_list, idx = get_layer_fields(layer_name, pattern)

        if len(champs_list) > 1:
            target_combobox.addItems(champs_list)
            target_combobox.setCurrentIndex(idx)

    def champsColonneComac(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs associée à la table sélectionnée"""
        self._populate_fields_combobox(
            self.dlg.comboBoxCoucheComac,
            self.dlg.comboBoxChampsComac
        )

    def champsColonneCapFt(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs colonne associée à la table sélectionnée"""
        self._populate_fields_combobox(
            self.dlg.capFtComboBox_etude_cap_ft,
            self.dlg.capFtComboBoxChampsCapFt,
            pattern=r'nom[_ ]?etudes|etudes'
        )

    def rafraichisement(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.coucheCombobox_etude_comac()
        self.coucheCombobox_etude_cap_ft()
        self.coucheCombobox_infra_pt_pot()
        self.dlg.smooth_progress.reset()

    def rafraichisementC6Bd(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.coucheCombobox_etude_cap_ft()
        self.coucheCombobox_etude_comac()
        self.coucheCombobox_infra_pt_pot()
        self.dlg.smooth_progress.reset()

    def rafraichisementMaj(self):
        """Rafraichit les QgsMapLayerComboBox de l'onglet MAJ"""
        self.dlg.textBrowser.clear()
        self.dlg.smooth_progress.reset()
        self.cocherDecocherAucunMaj()

    def rafraichisementC6C3aBd(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.coucheCombobox_infra_pt_pot()
        self.coucheComboboxC3a()
        self.coucheComboboxDecoupage()
        self.dlg.smooth_progress.reset()

    def _populate_layer_comboboxes(self, geom_types, comboboxes, default_pattern, error_msg, callback=None):
        """Helper pour peupler des combobox avec les couches filtrées par géométrie.
        
        Args:
            geom_types: Tuple des types de géométrie
            comboboxes: Liste des combobox à peupler
            default_pattern: Pattern regex pour sélection par défaut
            error_msg: Message d'erreur si aucune couche
            callback: Fonction optionnelle à appeler après
        """
        qgis_cbs = [cb for cb in comboboxes if isinstance(cb, QgsMapLayerComboBox)]
        qt_cbs = [cb for cb in comboboxes if not isinstance(cb, QgsMapLayerComboBox)]

        layer_list = get_layers_by_geometry(geom_types)

        if len(layer_list) == 1:
            self.alerteInfos(error_msg)
            return

        if qt_cbs:
            idx = find_default_layer_index(layer_list, default_pattern)
            for cb in qt_cbs:
                cb.clear()
                cb.addItems(layer_list)
                cb.setCurrentIndex(idx)

        if qgis_cbs:
            regexp = re.compile(default_pattern, re.IGNORECASE)
            vlyr = None
            warned = False
            for lyr in QgsProject.instance().mapLayers().values():
                if lyr.type() != QgsMapLayer.VectorLayer:
                    continue
                try:
                    if QgsWkbTypes.geometryType(lyr.wkbType()) not in geom_types:
                        continue
                except (TypeError, ValueError) as err:
                    if not warned:
                        QgsMessageLog.logMessage(
                            f"[PoleAerien._populate_layer_comboboxes] Type geom invalide: {err}",
                            "PoleAerien",
                            Qgis.Warning
                        )
                        warned = True
                    continue
                if regexp.search(lyr.name()):
                    vlyr = lyr
                    break

            for cb in qgis_cbs:
                cb.setProject(QgsProject.instance())
                cb.setFilters(QgsMapLayerProxyModel.HasGeometry)
                if vlyr is not None:
                    cb.setLayer(vlyr)

        if callback:
            callback()

    def coucheCombobox_infra_pt_pot(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        self._populate_layer_comboboxes(
            geom_types=(0, 3),
            comboboxes=[
                self.dlg.comacComboBoxCoucheInfra_pt_pot,
                self.dlg.capFtComboBoxCoucheInfra_pt_pot,
                self.dlg.C6BdcomboBox_infra_pt_pot,
                self.dlg.comboBox_infra_pt_pot_c6_c3a_bd
            ],
            default_pattern=r'infra_pt_pot',
            error_msg="Votre projet ne contient aucun shape de type Point (infra_pt_pot, ...)"
        )

    def coucheCombobox_etude_comac(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        self._populate_layer_comboboxes(
            geom_types=(2, 5),
            comboboxes=[self.dlg.comboBoxCoucheComac],
            default_pattern=r'comac',
            error_msg="Votre projet ne contient aucun shape de type Polygone (etude_comac, ...)",
            callback=lambda: (self.dlg.textBrowser.clear(), self.champsColonneComac())
        )

    def coucheCombobox_etude_cap_ft(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        self._populate_layer_comboboxes(
            geom_types=(2, 5),
            comboboxes=[
                self.dlg.capFtComboBox_etude_cap_ft,
                self.dlg.C6BdcomboBox_etude_cap_ft
            ],
            default_pattern=r'cap_ft',
            error_msg="Votre projet ne contient aucun shape de type Polygone (etude_cap_ft, ...)",
            callback=self.dlg.textBrowser.clear
        )

    def coucheComboboxC3a(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        self._populate_layer_comboboxes(
            geom_types=(1, 4),
            comboboxes=[self.dlg.comboBox_Cmd_c6_c3a_bd],
            default_pattern=r'cmd',
            error_msg="Votre projet ne contient aucun shape de type Point (infra_pt_pot, ...)",
            callback=self.dlg.textBrowser.clear
        )

    def coucheComboboxDecoupage(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        self._populate_layer_comboboxes(
            geom_types=(2, 5),
            comboboxes=[self.dlg.comboBox_Decoupage],
            default_pattern=r'etude.*cap_ft|cap_ft',
            error_msg="Votre projet ne contient aucun shape de type Polygone (etude_cap_ft, ...)",
            callback=lambda: (self.dlg.textBrowser.clear(), self.plc6champsDecoupage())
        )

    ########################################### BOUTON : POLICE C6 ####################################################
    def plc6champsDecoupage(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs colonne associée à la table sélectionnée"""
        self._populate_fields_combobox(
            self.dlg.comboBox_Decoupage,
            self.dlg.comboBox_Dcp_champs,
            pattern=r'nom[_ ]?etudes|etudes|ref_fci'
        )

    def plc6Rafraichisement(self):
        """Fonction pour rafraîchir l'interface QGIS notamment les couches"""
        self.dlg.textBrowser.clear()
        self.plc6ComboboxCoucheDecoupage()
        self.plc6ComboboxCoucheBpe()
        self.plc6ComboboxCoucheAttaches()
        self.dlg.smooth_progress.reset()

    def plc6CocherDecocherAucun(self):
        """Fonction pour cocher ou décocher l'interface de la phase 2"""
        ############################# ANALYSE COMAC ####################################
        # Vérif chemin GraceTHD
        chemin_gthd = self.dlg.c6LienCheminGraceThd.text()
        gthd_valide = chemin_gthd and os.path.isdir(chemin_gthd)
        
        sqlite_ok = False
        if hasattr(self.dlg, 'c6LienCheminSqlite'):
            sqlite_path = self.dlg.c6LienCheminSqlite.text().strip()
            sqlite_ok = bool(sqlite_path) and bool(getattr(self, '_plc6_sqlite_is_valid', False))

        source_gracethd_ok = gthd_valide or sqlite_ok
        
        if (not self.dlg.c6ComboBoxCoucheBpe.currentText() or not self.dlg.c6ComboBoxCoucheEtudes.currentText() or
            not self.dlg.c6ComboBoxCoucheAttaches.currentText() or
                not self.dlg.c6comboBoxColonneDecoupage.currentText() or
                not self.dlg.c6ComboBoxValeur.currentText() or
                not os.path.exists(self.dlg.C6LienCheminImportFichier.text()) or
                not source_gracethd_ok):
            self.dlg.c6Lanceur.setEnabled(False)

        else:
            self.dlg.c6Lanceur.setEnabled(True)

    def error(self, errorStr):
        """Fonction pour afficher des messages d'erreur"""
        # function to return error
        msg = str(errorStr)
        QMessageBox.warning(self.iface.mainWindow(), self.MSG_BOX_TITLE, msg)
        QgsMessageLog.logMessage(f"[PoleAerien.error] {msg}", "PoleAerien", Qgis.Warning)
        self.dlg.close()

    def plc6ComboboxCoucheDecoupage(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        self._populate_layer_comboboxes(
            geom_types=(2, 5),
            comboboxes=[self.dlg.c6ComboBoxCoucheEtudes],
            default_pattern=r'etude.*cap_ft|cap_ft',
            error_msg="Votre projet ne contient aucune couche de type Polygone (etude_cap_ft OU decoupage...)",
            callback=lambda: (self.dlg.textBrowser.clear(), self.plc6ColonneCombobox())
        )

    def plc6ComboboxCoucheBpe(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        self._populate_layer_comboboxes(
            geom_types=(0, 3),
            comboboxes=[self.dlg.c6ComboBoxCoucheBpe],
            default_pattern=r'bpe',
            error_msg="Votre projet ne contient aucune couche de type Polygone (etude_cap_ft OU decoupage...)",
            callback=self.dlg.textBrowser.clear
        )

    def plc6ComboboxCoucheAttaches(self):
        """ fonction qui permet de recupérer et d'afficher les noms des TABLES, de type polygones"""
        self._populate_layer_comboboxes(
            geom_types=(1, 4),
            comboboxes=[self.dlg.c6ComboBoxCoucheAttaches],
            default_pattern=r'attaches',
            error_msg="Votre projet ne contient aucune couche de type Polygone (etude_cap_ft OU decoupage...)",
            callback=self.dlg.textBrowser.clear
        )

    def plc6AutoDetectFichierC6(self):
        """Auto-détecte le fichier C6 basé sur la valeur nom_etudes sélectionnée"""
        nom_etude = self.dlg.c6ComboBoxValeur.currentText()
        if not nom_etude:
            return
        
        # Répertoire de recherche: répertoire courant
        search_dir = os.getcwd()
        
        # Patterns de recherche (priorité décroissante)
        patterns = [
            f"*{nom_etude}*.xlsx",
            f"*Annexe*C6*{nom_etude}*.xlsx",
            f"*C6*{nom_etude}*.xlsx",
        ]
        
        for pattern in patterns:
            matches = glob.glob(os.path.join(search_dir, pattern))
            if matches:
                # Prend le premier fichier trouvé
                self.dlg.C6LienCheminImportFichier.setText(matches[0])
                return

    def choixDossierImportFichierC6(self):
        """Fonction pour choisir le fichier qui doit être analysé (fallback manuel)"""
        self.dlg.smooth_progress.reset()
        fname = QFileDialog.getOpenFileName(None, f"Veuillez sélectionner le fichier EXCEL à analyser", "",
                                            "Fichier (*.xlsx)")[0]

        # Pour changer le dossier de travail par défaut
        if os.access(fname, os.W_OK):
            self.dlg.C6LienCheminImportFichier.setText(fname)
            dossier = os.path.dirname(fname)
            os.chdir(dossier)
            return

    def plc6ChoixDossierRepertoireGraceTHD(self):
        """Fonction pour choisir le repertoire à partir duquel je souhaite IMPORTER des couches"""
        self.dlg.smooth_progress.reset()
        repertoireGTHD = QFileDialog.getExistingDirectory(self.dlg,
                                                          f"Sélectionner votre repertoire d'importation des fichiers", "")
        if os.access(repertoireGTHD, os.W_OK):
            self.dlg.c6LienCheminGraceThd.setText(repertoireGTHD)
            return

    def plc6ChoixFichierSqlite(self):
        fname = QFileDialog.getOpenFileName(
            self.dlg,
            "Sélectionner le fichier GraceTHD (SQLite)",
            "",
            "Fichiers SQLite (*.sqlite *.db);;Tous les fichiers (*.*)"
        )[0]
        if fname:
            self.dlg.c6LienCheminSqlite.setText(fname)

    def plc6ChoixDossierRepertoireComac(self):
        repertoire = QFileDialog.getExistingDirectory(
            self.dlg,
            "Sélectionner le répertoire des études COMAC",
            ""
        )
        if repertoire and os.access(repertoire, os.W_OK):
            self.dlg.c6LienCheminComac.setText(repertoire)

    def plc6ValiderFichierSqlite(self):
        if not hasattr(self.dlg, 'c6LienCheminSqlite') or not hasattr(self.dlg, 'c6SqliteStatus'):
            return

        path = self.dlg.c6LienCheminSqlite.text().strip()
        self._plc6_sqlite_is_valid = False

        if not path:
            self.dlg.c6SqliteStatus.setText('Aucun fichier sélectionné')
            self.dlg.c6SqliteStatus.setStyleSheet('color:#64748b;font-size:9pt;')
            return

        if not os.path.exists(path):
            self.dlg.c6SqliteStatus.setText('Fichier introuvable')
            self.dlg.c6SqliteStatus.setStyleSheet('color:#ef4444;font-size:9pt;')
            return

        try:
            conn = sqlite3.connect(path)
            try:
                cur = conn.cursor()
                cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = {str(r[0]).lower() for r in cur.fetchall() if r and r[0]}
            finally:
                conn.close()
        except (sqlite3.Error, OSError) as e:
            self.dlg.c6SqliteStatus.setText('SQLite illisible')
            self.dlg.c6SqliteStatus.setStyleSheet('color:#ef4444;font-size:9pt;')
            QgsMessageLog.logMessage(
                f"[POLICE_C6] Validation SQLite: {e}",
                "PoleAerien", Qgis.Warning
            )
            return

        tables_min = {'appui', 'ebp', 'pbo'}
        tables_gracethd = {'t_cheminement', 't_cableline', 't_noeud', 't_ptech', 't_cable', 't_sitetech'}
        ok = tables_min.issubset(tables) or tables_gracethd.issubset(tables)
        if not ok:
            self.dlg.c6SqliteStatus.setText('SQLite non compatible')
            self.dlg.c6SqliteStatus.setStyleSheet('color:#ef4444;font-size:9pt;')
            return

        self._plc6_sqlite_is_valid = True
        self.dlg.c6SqliteStatus.setText('SQLite valide')
        self.dlg.c6SqliteStatus.setStyleSheet('color:#22c55e;font-size:9pt;')

    def plc6ColonneCombobox(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs associée à la table sélectionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable

        decompte = 0

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        champs_list = ['']
        self.dlg.c6comboBoxColonneDecoupage.clear()

        for layer in layers:
            if layer.name() == self.dlg.c6ComboBoxCoucheEtudes.currentText():
                decompte += 1

                for champs in layer.fields():
                    champs_list.append(str(champs.name()))

        if decompte == 0:
            self.dlg.c6comboBoxColonneDecoupage.clear()
            self.dlg.c6ComboBoxValeur.clear()

        else:
            # On insère des données colonnes dans le Combobox
            self.dlg.c6comboBoxColonneDecoupage.addItems(champs_list)

            # On définit la valeur par défaut de la couche s'il y a un champs du nom de 'etude'
            for valeur in champs_list:
                regexp = re.compile(r'etude*')
                regexp2 = re.compile(r'adress*')
                regexpRefci = re.compile(r'ref_fci')
                if (regexp.search(valeur.lower()) or regexp2.search(valeur.lower()) or
                        regexp2.search(valeur.lower()) or regexpRefci.search(valeur.lower())):
                    self.dlg.c6comboBoxColonneDecoupage.setCurrentIndex(champs_list.index(valeur))
                    break

            self.plc6ValeurCombobox()

    def plc6ValeurCombobox(self):
        """Fonction qui permet de récuperer et d'afficher les VALEURS associées au champs et à la table séléctionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable
        decompte = 0

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        valeurs_list = ['']
        self.dlg.c6ComboBoxValeur.clear()

        valeurs_unique = ""

        for layer in layers:
            if layer.name() == self.dlg.c6ComboBoxCoucheEtudes.currentText():

                # layer sera utilisé plus tard dans les autres fonctions.
                # On récupère la position du champs (colonne) nommé "etude" qui contient les noms des études
                if self.dlg.c6comboBoxColonneDecoupage.currentText():
                    idx_champs = layer.dataProvider().fields().indexFromName(self.dlg.c6comboBoxColonneDecoupage.currentText())
                    valeurs_unique = layer.dataProvider().uniqueValues(idx_champs)
                    decompte += 1

        if decompte == 0:
            self.dlg.c6ComboBoxValeur.clear()

        else:
            for valeur in valeurs_unique:
                # Si la commune n'existe pas déjà, on la rajoute
                valeurs_list.append(str(valeur))

            self.dlg.c6ComboBoxValeur.addItems(sorted(valeurs_list))

    def plc6analyserGlobal(self):
        """Fonction pour parcourir les fichiers Excel pour renseigner la référence des appuis via PoliceWorkflow."""
        self._reset_msgexporter()
        self.dlg.textBrowser.clear()
        
        # 1. Verification couches
        liste_absent = self.police_workflow.check_layers_exist()
        if liste_absent:
            alerte = f"Impossible de continuer. Les couches suivantes doivent exister dans QGIS :"
            alerte1 = ", ".join(liste_absent)
            self.alerteInfos(alerte)
            self.alerteInfos(alerte1)
            self.sc.alerteCritique(f"Les données svtes doivent n'exister dans QGIS : {alerte1}")
            return

        # Visual feedback
        self.dlg.start_processing('c6Lanceur', 'Analyse Police C6')
        self.dlg.smooth_progress.reset()
        self.dlg.smooth_progress.set_target(5)

        # 2. Importation Données
        if not self.Plc6ImportationDonneesDansQgis():
            # Error handled inside
            return

        # 3. Preparation parametres
        filterValeur = self.dlg.c6ComboBoxValeur.currentText()
        
        # Validation specifique (caracteres speciaux)
        voyelles = f"àâäéèêëîïôöùûüÿ'ÀÂÄÉÈÊËÎÏÔÖÙÛÜŸ"
        for car in voyelles:
            if car in filterValeur:
                alerte = (f"Le nom de l'étude ne doit pas contenir de caractères spéciaux, "
                          f"accentués ou apostrophes:")
                self.alerteInfos(alerte)
                self.dlg.smooth_progress.reset()
                self.dlg.end_processing_error('c6Lanceur', 'Erreur')
                return

        params = {
            'fname': self.dlg.C6LienCheminImportFichier.text(),
            'bpe': self.dlg.c6ComboBoxCoucheBpe.currentText(),
            'filterValeur': filterValeur,
            'attaches': self.dlg.c6ComboBoxCoucheAttaches.currentText(),
            'table_etude': self.dlg.c6ComboBoxCoucheEtudes.currentText(),
            'colonne_etude': self.dlg.c6comboBoxColonneDecoupage.currentText()
        }

        if hasattr(self.dlg, 'c6ComboBoxZoneDecoupage'):
            zone_lyr = self.dlg.c6ComboBoxZoneDecoupage.currentLayer()
            if zone_lyr and zone_lyr.isValid():
                params['zone_layer_name'] = zone_lyr.name()

        # 4. Lancement Analyse (Main Thread avec events)
        self.police_workflow.reset_logic()
        
        # Enregistrement pour annulation (simulation car pas de QgsTask ici, mais permet de gerer l'etat)
        # Note: PoliceWorkflow n'est pas une QgsTask, donc on ne peut pas l'annuler via taskManager.
        # Mais on garde le statut "processing"
        
        self.police_workflow.run_analysis(params)

    def _onPoliceProgress(self, value):
        """Callback progression Police C6"""
        if not self._dlg_alive():
            return
        self.dlg.smooth_progress.set_target(value)

    def _onPoliceMessage(self, msg, couleur):
        """Callback message Police C6"""
        if not self._dlg_alive():
            return
        self.alerteInfos(msg, couleur=couleur)
        # Accumuler pour export texte si non vide
        if msg:
             self.msgexporter += f"{msg}\n"

    def _onPoliceAnalysisFinished(self, result):
        """Callback fin analyse Police C6 - Gestion post-analyse (couches erreurs)"""
        if not self._dlg_alive():
            return
        
        filterValeur = result.get('filterValeur')
        
        # Création couches erreurs via SecondFile (sc)
        
        # 1. Appuis absents
        if result.get('nb_appui_absent', 0) > 0:
            poteaux = "infra_pt_pot"
            infNumPotAbsent = result.get('infNumPotAbsent', [])
            if infNumPotAbsent:
                condition = tuple(infNumPotAbsent) if len(infNumPotAbsent) > 1 else f"({infNumPotAbsent[0]})"
                self.sc.createNewLayer("gid", condition, poteaux, "Point", 'manquant', filterValeur)
                self.police_workflow.apply_style(f"error_{poteaux}_manquant")

        # 2. EBP non appui
        ebp_non_appui = result.get('ebp_non_appui', [])
        fied_id_Ebp = result.get('fied_id_Ebp', 'gid')
        if ebp_non_appui:
            # Note: On suppose couche 'bpe' par défaut ou on devrait la passer dans result
            # Pour l'instant on utilise 'bpe' hardcodé comme dans le code original implicitement via variable locale
            bpe_layer_name = self.dlg.c6ComboBoxCoucheBpe.currentText() or "bpe"
            condition = tuple(ebp_non_appui) if len(ebp_non_appui) > 1 else f"({ebp_non_appui[0]})"
            self.sc.createNewLayer(fied_id_Ebp, condition, bpe_layer_name, "Point", "pas_intersect", filterValeur)
            self.police_workflow.apply_style(f"error_{bpe_layer_name}_pas_intersect")

        # 3. EBP appui inconnu
        ebp_appui_inconnu = result.get('ebp_appui_inconnu', [])
        if ebp_appui_inconnu:
            appui_bpe = "infra_pt_pot"
            listeBpeAppuiGidAbsent = [item[0] for item in ebp_appui_inconnu]
            if listeBpeAppuiGidAbsent:
                condition = tuple(listeBpeAppuiGidAbsent) if len(listeBpeAppuiGidAbsent) > 1 else f"({listeBpeAppuiGidAbsent[0]})"
                self.sc.createNewLayer('gid', condition, appui_bpe, "Point", "ebp", filterValeur)
                self.police_workflow.apply_style(f"error_{appui_bpe}_ebp")

        etape = "Fin de l'exécution du programme"
        self.alerteInfos(etape, couleur="grey")
        self.msgexporter += f"\n{etape}"
        
        self.dlg.smooth_progress.set_target(100)
        self.dlg.end_processing_success('c6Lanceur', 'Terminé')

    def _onPoliceError(self, error_msg):
        """Callback erreur Police C6"""
        if not self._dlg_alive():
            return
        self.alerteInfos(f"Erreur: {error_msg}", couleur="red")
        self.dlg.smooth_progress.reset()
        self.dlg.end_processing_error('c6Lanceur', 'Erreur')

    def Plc6ImportationDonneesDansQgis(self):
        """On teste si les fichiers souhaités existent à l'emplacement indiqué."""
        sqlite_path = self.dlg.c6LienCheminSqlite.text().strip() if hasattr(self.dlg, 'c6LienCheminSqlite') else ''
        repertoireGTHD = self.dlg.c6LienCheminGraceThd.text()

        # Délégué au workflow
        success, msg = self.police_workflow.import_gracethd_data(repertoireGTHD, sqlite_path)
        
        if not success:
            alerte = f"Les dossiers GRACETHD indiqués ne contient pas les fichiers suivants :\n{msg}"
            self.alerteInfos(alerte, False, "red")
            self.msgexporter = alerte
            self.sc.alerteCritique(alerte)
            self.dlg.smooth_progress.reset()
            return False
            
        return True

    ########################################### FIN #####################################################
    def valeurChampsDecoupage(self):
        """ fonction qui permet de recupérer et d'afficher les noms des champs associée à la table sélectionnée"""
        # Création d'une variable fetcable qui parcours la table t_cable
        # layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        self.dlg.comboBox_Dcp_Valeur_champs.clear()

        decoupage = self.dlg.comboBox_Decoupage.currentText()
        champs = self.dlg.comboBox_Dcp_champs.currentText()

        if decoupage and champs:
            layers = QgsProject.instance().mapLayersByName(decoupage)
            if not layers:
                self.dlg.comboBox_Dcp_Valeur_champs.clear()
                return
            layer = layers[0]
            if not layer.isValid():
                self.dlg.comboBox_Dcp_Valeur_champs.clear()
                return
            try:
                idx_ref_fci = layer.dataProvider().fields().indexFromName(champs)
                if idx_ref_fci >= 0:
                    ref_fci = [str(v) for v in layer.dataProvider().uniqueValues(idx_ref_fci) if v]
                    if ref_fci:
                        self.dlg.comboBox_Dcp_Valeur_champs.addItems(ref_fci)
                    else:
                        self.dlg.comboBox_Dcp_Valeur_champs.clear()
                else:
                    self.dlg.comboBox_Dcp_Valeur_champs.clear()
            except (RuntimeError, TypeError, ValueError):
                self.dlg.comboBox_Dcp_Valeur_champs.clear()
        else:
            self.dlg.comboBox_Dcp_Valeur_champs.clear()

    def analyserFichiersCapFt(self):
        """Lance l'analyse CAP_FT en arriere-plan (non-bloquant) via CapFtWorkflow"""
        self._reset_msgexporter()
        self._capft_start_time = time.time()
        self.dlg.textBrowser.clear()
        
        # Visual feedback + smooth progress
        self.dlg.start_processing('cap_ftLanceur', 'Analyse CAP_FT')
        self.dlg.smooth_progress.reset()
        self.dlg.smooth_progress.set_target(5)

        # Récupération des objets couches
        lyr_pot = self.dlg.capFtComboBoxCoucheInfra_pt_pot.currentLayer()
        lyr_cap = self.dlg.capFtComboBox_etude_cap_ft.currentLayer()
        col_cap = self.dlg.capFtComboBoxChampsCapFt.currentText()
        cheminCap_ft = self.dlg.lienRepertoireCapFt.text()
        cheminExportExcel = self.dlg.lienCheminExportCapFt.text()

        # Validation entrees (UI feedback)
        if not lyr_pot or not lyr_cap:
             self.alerteInfos("Couches non sélectionnées ou invalides", couleur="red")
             self.dlg.end_processing_error('cap_ftLanceur', 'Erreur config')
             return

        if not os.path.isdir(cheminCap_ft):
            self.alerteInfos("Veuillez choisir le chemin contenant les fichiers Excels des ETUDES CAF_FT")
            self.dlg.lienRepertoireCapFt.setStyleSheet("""QLineEdit {background-color: orange; }""")
            self.dlg.end_processing_error('cap_ftLanceur', 'Erreur config')
            return

        if not os.path.isdir(cheminExportExcel):
            self.alerteInfos("Veuillez choisir le chemin d'exportation du fichier à générer")
            self.dlg.lienCheminExportCapFt.setStyleSheet("""QLineEdit {background-color: orange; }""")
            self.dlg.end_processing_error('cap_ftLanceur', 'Erreur config')
            return

        # Délégué au workflow
        self.capft_workflow.start_analysis(
            lyr_pot, lyr_cap, col_cap,
            cheminCap_ft, cheminExportExcel
        )
        
        # Enregistrement task pour annulation
        if self.capft_workflow.current_task:
            self.dlg.register_task('cap_ftLanceur', self.capft_workflow.current_task)

    def _onCapFtProgress(self, value):
        """Callback progression fluide CAP_FT"""
        if not self._dlg_alive():
            return
        self.dlg.smooth_progress.set_target(value)

    def _onCapFtMessage(self, msg, color):
        """Callback message CAP_FT"""
        if not self._dlg_alive():
            return
        self.alerteInfos(msg, False, color)

    def _onCapFtAnalysisFinished(self, result):
        """Callback fin analyse CAP_FT - Déclenche l'export ou affiche les erreurs"""
        if not self._dlg_alive():
            return
        # Check error types
        if result.get('error_type'):
            err_type = result['error_type']
            data = result['data']
            
            if err_type == 'doublons':
                alerte = "Deux ou plusieurs études portent le nom même\n:" + str(data)
                self.alerteInfos(alerte, False, "red")
                self.msgexporter = alerte
            elif err_type == 'hors_etude':
                alerte = "Des poteaux FT qui n'intersectent aucun découpage des études CAP-FT:\n" + str(data)
                self.alerteInfos(alerte, False, "orange")
                self.msgexporter = alerte
            
            self.dlg.smooth_progress.reset()
            self.dlg.unregister_task('cap_ftLanceur')
            self.dlg.end_processing_error('cap_ftLanceur', 'Erreur')
            return

        # Si succès, lancer l'export via le workflow
        if result.get('pending_export'):
            self.capft_workflow.start_export(result)
        else:
            # Si pas d'export, afficher directement
            self._onCapFtExportFinished(result)

    def _onCapFtExportFinished(self, result):
        """Callback fin export CAP_FT - Affiche les résultats dans l'UI"""
        if not self._dlg_alive():
            return

        # Success - afficher resultats
        dico_excel_intro = result.get('dico_excel_introuvable', {})
        dico_qgis_intro = result.get('dico_qgis_introuvable', {})
        fichier_export = result.get('fichier_export', '')

        if dico_excel_intro:
            alerte = "******* PRESENCE DANS LES FICHES APPUIS, MAIS ABSENT DE QGIS  *******"
            self.alerteInfos(alerte, False, "grey")
            self.msgexporter = f"{alerte}\n"

            for excel, appuis_list in dico_excel_intro.items():
                for appuis in appuis_list:
                    alerte = f"{appuis} dans le fichier : {excel}"
                    self.alerteInfos(alerte, False, "orange")
                    self.msgexporter += alerte + "\n"
            self.alerteInfos("", False, "grey")

        if dico_qgis_intro:
            alerte = "******* PRESENCE QGIS, MAIS ABSENT DES FICHES APPUIS  *******"
            self.alerteInfos(alerte, False, "grey")
            self.msgexporter += f"{alerte}\n"

            for excel, appuis_list in dico_qgis_intro.items():
                for appuis in appuis_list:
                    alerte = f"{appuis} dans l'étude : {excel}"
                    self.alerteInfos(alerte, False, "orange")
                    self.msgexporter += f"{alerte}\n"

        self.dlg.boutonCheminExport.setEnabled(True)

        if not dico_excel_intro and not dico_qgis_intro:
            etape = "Vos données correspondent parfaitement, Aucune erreur n'a été trouvée"
            self.alerteInfos(etape, False, "green")
            self.msgexporter += f"\n{etape}\n"

        etape = f"Le fichier d'analyse a bien été généré dans le chemin ci dessous :\n{fichier_export}"
        self.alerteInfos(etape, False, "green")
        self.msgexporter += f"\n{etape}\n"

        etape = f"Fin de l'exécution du programme en {self.sc.tempsEcouler(time.time() - self._capft_start_time)}"
        self.alerteInfos(etape, False, "grey")
        self.msgexporter += f"\n{etape}"
        
        self.dlg.smooth_progress.set_target(100)
        self.dlg.unregister_task('cap_ftLanceur')
        self.dlg.end_processing_success('cap_ftLanceur', 'Analyse terminee')

    def _onCapFtError(self, error_msg):
        """Callback erreur CAP_FT"""
        if not self._dlg_alive():
            return
        self.alerteInfos(f"Erreur: {error_msg}", False, "red")
        self.dlg.smooth_progress.reset()
        self.dlg.unregister_task('cap_ftLanceur')
        self.dlg.end_processing_error('cap_ftLanceur', 'Erreur')

    def analyserFichiersComac(self):
        """Lance l'analyse COMAC en arriere-plan (non-bloquant) via ComacWorkflow"""
        self._reset_msgexporter()
        self._comac_start_time = time.time()
        self.dlg.textBrowser.clear()
        
        # Visual feedback + smooth progress
        self.dlg.start_processing('cap_comacLanceur', 'Analyse COMAC')
        self.dlg.smooth_progress.reset()
        self.dlg.smooth_progress.set_target(5)

        # Récupération des objets couches (QgsVectorLayer)
        lyr_pot = self.dlg.comacComboBoxCoucheInfra_pt_pot.currentLayer()
        lyr_comac = self.dlg.comboBoxCoucheComac.currentLayer()
        col_comac = self.dlg.comboBoxChampsComac.currentText()
        cheminComac = self.dlg.lienRepertoireComac.text()
        cheminExportExcel = self.dlg.lienCheminExportComac.text()

        # Validation entrees (UI feedback)
        if not lyr_pot or not lyr_comac:
             self.alerteInfos("Couches non sélectionnées ou invalides", couleur="red")
             self.dlg.end_processing_error('cap_comacLanceur', 'Erreur config')
             return

        if not os.path.isdir(cheminComac):
            self.alerteInfos("Veuillez choisir le chemin contenant les fichiers Excels des ETUDES COMAC")
            self.dlg.lienRepertoireComac.setStyleSheet("""QLineEdit {background-color: orange; }""")
            self.dlg.end_processing_error('cap_comacLanceur', 'Erreur config')
            return

        if not os.path.isdir(cheminExportExcel):
            self.alerteInfos("Veuillez choisir le chemin d'exportation du fichier à générer")
            self.dlg.lienCheminExportComac.setStyleSheet("""QLineEdit {background-color: orange; }""")
            self.dlg.end_processing_error('cap_comacLanceur', 'Erreur config')
            return

        # Délégué au workflow
        self.comac_workflow.start_analysis(
            lyr_pot, lyr_comac, col_comac,
            cheminComac, cheminExportExcel
        )
        
        # Enregistrement task pour annulation
        if self.comac_workflow.current_task:
            self.dlg.register_task('cap_comacLanceur', self.comac_workflow.current_task)

    def _onComacProgress(self, value):
        """Callback progression fluide COMAC"""
        if not self._dlg_alive():
            return
        self.dlg.smooth_progress.set_target(value)

    def _onComacMessage(self, msg, color):
        """Callback message COMAC"""
        if not self._dlg_alive():
            return
        self.alerteInfos(msg, False, color)

    def _onComacAnalysisFinished(self, result):
        """Callback fin analyse COMAC - Déclenche l'export ou affiche les erreurs"""
        if not self._dlg_alive():
            return
            
        # Check error types
        if result.get('error_type'):
            err_type = result['error_type']
            data = result['data']
            
            if err_type == 'doublons':
                alerte = f"Deux ou plusieurs études portent le nom même\n:{data}"
                self.alerteInfos(alerte, False, "red")
                self.msgexporter = alerte
            elif err_type == 'hors_etude':
                alerte = f"WARNING ! Des poteaux BT n'appartiennent pas aux études présentes dans QGIS : {data}"
                self.alerteInfos(alerte, False, "orange")
                self.msgexporter = alerte
            elif err_type == 'fichiers_doublons':
                erreurs = "ERREURS : les fichiers ci-dessous existent en doublon\nVeuillez corriger ses erreurs avant de rélancer le programme"
                self.alerteInfos(erreurs, False, "red")
                for fichier in data:
                    self.alerteInfos(str(fichier), False, "orange")
                self.msgexporter = erreurs
            elif err_type == 'erreur_lecture':
                erreurs = "L'ERREUR ci-dessous a été générée\nAssurez-vous de bien fermer ce fichier avant de rélancer le programme"
                self.alerteInfos(erreurs, False, "red")
                for fichier, typeErreur in data.items():
                    self.alerteInfos(f"fichier : {fichier}:\nErreur : {typeErreur}", False, "orange")
                self.msgexporter = erreurs
            
            self.dlg.smooth_progress.reset()
            self.dlg.unregister_task('cap_comacLanceur')
            self.dlg.end_processing_error('cap_comacLanceur', 'Erreur')
            return

        # Si succès, lancer l'export via le workflow
        if result.get('pending_export'):
            self.comac_workflow.start_export(result)
        else:
            # Si pas d'export (cas rare ou info seule), afficher directement
            self._onComacExportFinished(result)

    def _onComacExportFinished(self, result):
        """Callback fin export COMAC - Affiche les résultats dans l'UI"""
        if not self._dlg_alive():
            return

        # Info utile: zone climatique détectée
        zone_clim = result.get('zone_climatique', 'ZVN')
        self._log.result("Zone climatique détectée", zone_clim, "success")
        
        # Success - afficher resultats
        dico_excel_intro = result.get('dico_excel_introuvable', {})
        dico_qgis_intro = result.get('dico_qgis_introuvable', {})
        fichier_export = result.get('fichier_export', '')

        if dico_excel_intro:
            alerte = "******* PRESENCE DANS EXCEL, MAIS ABSENT DE QGIS  *******"
            self.alerteInfos(alerte, False, "grey")
            self.msgexporter = f"{alerte}\n"

            for excel, appuis_list in dico_excel_intro.items():
                for appuis in appuis_list:
                    alerte = f"{appuis} dans le fichier : {excel}"
                    self.alerteInfos(alerte, False, "orange")
                    self.msgexporter += alerte + "\n"
            self.alerteInfos("", False, "grey")

        if dico_qgis_intro:
            alerte = "******* PRESENCE QGIS, MAIS ABSENT DES EXCELS  *******"
            self.alerteInfos(alerte, False, "grey")
            self.msgexporter += f"{alerte}\n"

            for excel, appuis_list in dico_qgis_intro.items():
                for appuis in appuis_list:
                    alerte = f"{appuis} dans l'étude : {excel}"
                    self.alerteInfos(alerte, False, "orange")
                    self.msgexporter += f"{alerte}\n"

        self.dlg.boutonCheminExport.setEnabled(True)

        if not dico_excel_intro and not dico_qgis_intro:
            etape = "Vos données correspondent parfaitement, Aucune erreur n'a été trouvée"
            self.alerteInfos(etape, False, "green")
            self.msgexporter += f"\n{etape}\n"

        etape = f"Le fichier d'analyse a bien été généré dans le chemin ci dessous :\n{fichier_export}"
        self.alerteInfos(etape, False, "green")
        self.msgexporter += f"\n{etape}\n"

        etape = f"Fin de l'exécution du programme en {self.sc.tempsEcouler(time.time() - self._comac_start_time)}"
        self.alerteInfos(etape, False, "grey")
        self.msgexporter += f"\n{etape}"
        
        self.dlg.smooth_progress.set_target(100)
        self.dlg.unregister_task('cap_comacLanceur')
        self.dlg.end_processing_success('cap_comacLanceur', 'Analyse terminee')

    def _onComacError(self, error_msg):
        """Callback erreur COMAC"""
        if not self._dlg_alive():
            return
        self.alerteInfos(f"Erreur: {error_msg}", False, "red")
        self.dlg.smooth_progress.reset()
        self.dlg.unregister_task('cap_comacLanceur')
        self.dlg.end_processing_error('cap_comacLanceur', 'Erreur')

    def comparaisonC6BaseDonnees(self):
        """Lance la comparaison C6 vs BD en arrière-plan (non-bloquant) via C6BdWorkflow.
        
        Fonctionnalités:
        - Liste des poteaux FT couverts par polygones CAP FT (IN)
        - Liste des poteaux FT NON couverts (OUT)
        - Vérification noms études vs fichiers C6
        - Auto-détection du champ étude dans la couche CAP FT
        """
        self.dlg.textBrowser.clear()
        self._c6bd_start_time = time.time()
        
        # Visual feedback + smooth progress
        self.dlg.start_processing('C6BdLanceur', 'Comparaison C6')
        self.dlg.smooth_progress.reset()
        self.dlg.smooth_progress.set_target(5)

        # Récupération des entrées
        repertoire_c6 = self.dlg.lienCheminFichiersC6.text()
        lyr_pot = self.dlg.C6BdcomboBox_infra_pt_pot.currentLayer()
        lyr_cap = self.dlg.C6BdcomboBox_etude_cap_ft.currentLayer()
        cheminExportExcel = self.dlg.lienCheminExportDonnees.text()
        
        # Auto-détection du champ étude (None = auto-detect dans workflow)
        col_cap = None

        # Validation entrées (UI feedback)
        if not lyr_pot or not lyr_cap:
            self.alerteInfos("Couches non sélectionnées ou invalides", couleur="red")
            self.dlg.end_processing_error('C6BdLanceur', 'Erreur config')
            return

        if not os.path.isdir(repertoire_c6):
            self.alerteInfos("Veuillez choisir le répertoire contenant les fichiers C6")
            self.dlg.lienCheminFichiersC6.setStyleSheet("QLineEdit {background-color: orange;}")
            self.dlg.end_processing_error('C6BdLanceur', 'Erreur config')
            return

        if not os.path.isdir(cheminExportExcel):
            self.alerteInfos("Veuillez choisir le chemin d'exportation")
            self.dlg.lienCheminExportDonnees.setStyleSheet("QLineEdit {background-color: orange;}")
            self.dlg.end_processing_error('C6BdLanceur', 'Erreur config')
            return

        # Enregistrer callback annulation AVANT de lancer (extraction incrémentale avec QTimer)
        self.dlg.register_cancel_callback('C6BdLanceur', self.c6bd_workflow.cancel)

        # Délégué au workflow (col_cap=None → auto-détection)
        self.c6bd_workflow.start_analysis(
            lyr_pot, lyr_cap, col_cap,
            repertoire_c6, cheminExportExcel
        )

    def _onC6BdProgress(self, value):
        """Callback progression fluide C6 vs BD"""
        if not self._dlg_alive():
            return
        self.dlg.smooth_progress.set_target(value)

    def _onC6BdMessage(self, msg, color):
        """Callback message C6 vs BD"""
        if not self._dlg_alive():
            return
        self.alerteInfos(msg, False, color)

    def _onC6BdAnalysisFinished(self, result):
        """Callback fin analyse C6 vs BD - Déclenche l'export"""
        if not self._dlg_alive():
            return

        # Si succès, lancer l'export via le workflow
        if result.get('pending_export'):
            self.c6bd_workflow.start_export(result)
        else:
            # Si pas d'export, afficher directement (cas rare ici)
            self._onC6BdExportFinished(result)

    def _onC6BdExportFinished(self, result):
        """Callback fin export Excel C6 vs BD - Affiche les résultats"""
        if not self._dlg_alive():
            return
        fichier_export = result.get('fichier_export', '')
        final_df = result.get('final_df')

        # Compter erreurs
        nbre_erreurs = 0
        if final_df is not None and 'Statut' in final_df.columns:
            nbre_erreurs = len(final_df[final_df['Statut'] != 'OK'])

        if not nbre_erreurs:
            etape = "Vos données correspondent parfaitement, Aucune erreur n'a été trouvée"
            self.alerteInfos(etape, False, "green")
        else:
            etape = (f"{nbre_erreurs} erreur(s) ont été trouvées dans les données. "
                     f"\nVeuillez en prendre connaissance dans le fichier Excel")
            self.alerteInfos(etape, False, "red")

        etape = f"Le fichier d'analyse a bien été généré dans le chemin ci dessous :\n{fichier_export}"
        self.alerteInfos(etape, False, "green")

        etape = f"Fin de l'exécution du programme en {self.sc.tempsEcouler(time.time() - self._c6bd_start_time)}"
        self.alerteInfos(etape, False, "grey")

        self.dlg.smooth_progress.set_target(100)
        self.dlg.unregister_task('C6BdLanceur')
        self.dlg.unregister_cancel_callback('C6BdLanceur')
        self.dlg.end_processing_success('C6BdLanceur', 'Comparaison terminee')

    def _onC6BdError(self, error_msg):
        """Callback erreur C6 vs BD"""
        if not self._dlg_alive():
            return
        self.alerteInfos(f"Erreur: {error_msg}", False, "red")
        self.dlg.smooth_progress.reset()
        self.dlg.unregister_task('C6BdLanceur')
        self.dlg.unregister_cancel_callback('C6BdLanceur')
        self.dlg.end_processing_error('C6BdLanceur', 'Erreur')

    def comparaisonC6C3aBd(self):
        """Comparer les données C6 par rapport à la base de données via C6C3AWorkflow"""
        self.dlg.textBrowser.clear()
        
        # Visual feedback + smooth progress
        self.dlg.start_processing('c6_c3a_bdLanceur', 'Analyse C6/C3A')
        self.dlg.smooth_progress.reset()
        self.dlg.smooth_progress.set_target(5)

        self._c6c3a_start_time = time.time()

        params = {
            'fichier_c6': self.dlg.lienCheminC6_c6_c3a_bd.text(),
            'fichier_c7': self.dlg.lienCheminC7_c6_c3a_bd.text(),
            'table_infra': self.dlg.comboBox_infra_pt_pot_c6_c3a_bd.currentText(),
            'table_cmd': self.dlg.comboBox_Cmd_c6_c3a_bd.currentText(),
            'table_decoupage': self.dlg.comboBox_Decoupage.currentText(),
            'champs_dcp': self.dlg.comboBox_Dcp_champs.currentText(),
            'valeur_dcp': self.dlg.comboBox_Dcp_Valeur_champs.currentText(),
            'chemin_export': self.dlg.lienCheminExportDonnees_c6_c3a_bd.text(),
            'mode_c3a': 'QGIS' if self.dlg.radioButtonQgis.isChecked() else 'EXCEL'
        }
        
        if not params['mode_c3a'] == 'QGIS':
             params['fichier_c3a'] = self.dlg.lienCheminC3A_c6_c3a_bd.text()

        # Validation basique
        if not os.path.isdir(params['chemin_export']):
             self.alerteInfos("Veuillez choisir le chemin d'exportation", couleur="red")
             self.dlg.end_processing_error('c6_c3a_bdLanceur', 'Erreur config')
             return

        # Délégué au workflow
        self.c6c3a_workflow.start_analysis(params)
        
        # Note: Pas de QgsTask retournée ici car l'analyse est pour l'instant synchrone (Main Thread)
        # Mais on garde la structure pour le futur

    def _onC6C3AProgress(self, value):
        if not self._dlg_alive(): return
        self.dlg.smooth_progress.set_target(value)

    def _onC6C3AMessage(self, msg, color):
        if not self._dlg_alive(): return
        self.alerteInfos(msg, False, color)

    def _onC6C3AAnalysisFinished(self, result):
        if not self._dlg_alive(): return
        
        if result.get('success'):
             # Lancer l'export
             self.c6c3a_workflow.start_export(result)
        else:
             self.dlg.end_processing_error('c6_c3a_bdLanceur', 'Erreur')

    def _onC6C3AExportFinished(self, result):
        if not self._dlg_alive(): return
        
        file_1 = result.get('file_1')
        nb_err_1 = result.get('nb_err_1', 0)
        file_2 = result.get('file_2')
        nb_err_2 = result.get('nb_err_2', 0)
        
        # Rapport 1
        etape = f"Le fichier d'analyse a bien été généré dans le chemin ci dessous :\n{os.path.dirname(file_1)}"
        self.alerteInfos(etape, couleur="green")
        
        self.alerteInfos("############### COMPARAISON C6 vs C3A vs BD ###############", couleur="grey")
        if nb_err_1 == 0:
            self.alerteInfos("Vos données correspondent parfaitement, Aucune erreur n'a été trouvée", couleur="green")
        else:
            self.alerteInfos(f"{nb_err_1} erreur(s) ont été trouvées.\nVeuillez vérifier le fichier Excel\n{os.path.basename(file_1)}", couleur="red")

        # Rapport 2
        self.alerteInfos("############ REMPLACEMENT : COMPARAISON C6 vs C7 vs C3A vs BD ############", couleur="grey")
        if nb_err_2 == 0:
             self.alerteInfos("Vos données correspondent parfaitement, Aucune erreur n'a été trouvée", couleur="green")
        else:
             self.alerteInfos(f"{nb_err_2} erreur(s) ont été trouvées.\nVeuillez vérifier le fichier Excel\n{os.path.basename(file_2)}", couleur="red")
             
        # Fin
        duration = time.time() - self._c6c3a_start_time
        self.alerteInfos(f"Fin de l'exécution du programme en {self.sc.tempsEcouler(duration)}", couleur="grey")
        
        self.dlg.smooth_progress.set_target(100)
        self.dlg.unregister_task('c6_c3a_bdLanceur') # Au cas où
        self.dlg.end_processing_success('c6_c3a_bdLanceur', 'Terminé')

    def _onC6C3AError(self, error_msg):
        if not self._dlg_alive(): return
        self.alerteInfos(f"Erreur: {error_msg}", False, "red")
        self.dlg.smooth_progress.reset()
        self.dlg.end_processing_error('c6_c3a_bdLanceur', 'Erreur')

    def majDesDonnneesFtBt(self):
        """Lance la MAJ FT/BT en arriere-plan (non-bloquant) via MajWorkflow"""
        self.dlg.textBrowser.clear()
        
        # Visual feedback + smooth progress
        self.dlg.start_processing('majBdLanceur', 'Analyse MAJ')
        self.dlg.smooth_progress.reset()
        self.dlg.smooth_progress.set_target(5)

        # Validation couches avant extraction
        lyr_pot = self.dlg.MajcomboBox_infra_pt_pot.currentLayer()
        lyr_cap = self.dlg.MajcomboBox_etude_cap_ft.currentLayer()
        lyr_com = self.dlg.MajcomboBox_etude_comac.currentLayer()
        
        if not lyr_pot or not lyr_cap or not lyr_com:
            self.alerteInfos("Couches non sélectionnées", couleur="red")
            self.dlg.end_processing_error('majBdLanceur', 'Erreur config')
            return
            
        excel_path = self.dlg.MajFileWidget.filePath()
        if not excel_path:
             self.alerteInfos("Fichier Excel non sélectionné", couleur="red")
             self.dlg.end_processing_error('majBdLanceur', 'Erreur config')
             return

        # Délégué au workflow
        self.maj_workflow.start_analysis(lyr_pot, lyr_cap, lyr_com, excel_path)
        
        # Enregistrement pour annulation (si la tâche a bien été créée)
        if self.maj_workflow.current_task:
            self.dlg.register_task('majBdLanceur', self.maj_workflow.current_task)

    def _onMajProgress(self, value):
        """Callback progression fluide MAJ"""
        self.dlg.smooth_progress.set_target(value)

    def _onMajMessage(self, msg, couleur):
        """Callback message"""
        self.alerteInfos(msg, couleur=couleur)

    def _onMajError(self, err):
        """Callback erreur MAJ"""
        self.alerteInfos(f"Erreur: {err}", couleur="red")
        self.dlg.smooth_progress.reset()
        self.dlg.end_processing_error('majBdLanceur', 'Erreur')

    def _afficherTableau(self, df, titre, couleur="#ccc"):
        """Affiche DataFrame en tableau HTML dans le textBrowser (adaptatif theme)"""
        if df is None or df.empty:
            return

        html = f'<p><b style="color:{couleur}">{titre}</b></p>'
        html += '<table cellspacing="0" cellpadding="3" style="font-size:8pt">'

        # En-tetes avec couleur titre
        html += f'<tr style="background:{couleur}">'
        for col in df.columns:
            html += f'<th style="padding:3px 8px;color:#000">{col}</th>'
        html += '</tr>'

        # Lignes sans fond (adaptatif au theme)
        for _, row in df.iterrows():
            html += '<tr>'
            for val in row.values:
                v = str(val) if val is not None else ""
                html += f'<td style="padding:2px 6px">{v}</td>'
            html += '</tr>'

        html += '</table><br>'
        self.dlg.textBrowser.append(html)

    def _onMajFinished(self, result):
        """Callback fin analyse - affiche resultats dans table attributaire QGIS"""
        import time
        t0_callback = time.perf_counter()
        QgsMessageLog.logMessage("[PERF-MAJ] ======= DEBUT CALLBACK _onMajFinished (Main Thread) =======", "PoleAerien", Qgis.Info)
        
        QApplication.processEvents()
        
        liste_ft = result['liste_ft']
        liste_bt = result['liste_bt']

        tt_introuvable_ft, lst_introuvable_ft, tt_trouve_ft, lst_trouve_ft = liste_ft
        tt_introuvable_bt, lst_introuvable_bt, tt_trouve_bt, lst_trouve_bt = liste_bt

        t1 = time.perf_counter()
        QgsMessageLog.logMessage(f"[PERF-MAJ] Extraction resultats: {t1-t0_callback:.3f}s", "PoleAerien", Qgis.Info)

        # MAJ KPIs
        total = tt_trouve_ft + tt_trouve_bt
        self.dlg.update_kpi(0, 'total', str(total))
        self.dlg.update_kpi(0, 'ft', f"FT: {tt_trouve_ft}")
        self.dlg.update_kpi(0, 'bt', f"BT: {tt_trouve_bt}")
        self.dlg.set_page_status(0, 'done')
        QApplication.processEvents()
        
        t2 = time.perf_counter()
        QgsMessageLog.logMessage(f"[PERF-MAJ] MAJ KPIs: {t2-t1:.3f}s", "PoleAerien", Qgis.Info)

        # Affiche introuvables dans textBrowser
        if tt_introuvable_ft > 0:
            t3a = time.perf_counter()
            self._afficherTableau(lst_introuvable_ft, f"FT introuvables ({tt_introuvable_ft})", "#ff6b6b")
            QApplication.processEvents()
            t3b = time.perf_counter()
            QgsMessageLog.logMessage(f"[PERF-MAJ] Tableau FT introuvables: {t3b-t3a:.3f}s", "PoleAerien", Qgis.Info)

        if tt_introuvable_bt > 0:
            t4a = time.perf_counter()
            self._afficherTableau(lst_introuvable_bt, f"BT introuvables ({tt_introuvable_bt})", "#ff6b6b")
            QApplication.processEvents()
            t4b = time.perf_counter()
            QgsMessageLog.logMessage(f"[PERF-MAJ] Tableau BT introuvables: {t4b-t4a:.3f}s", "PoleAerien", Qgis.Info)

        # Aucune correspondance
        if tt_trouve_ft == 0 and tt_trouve_bt == 0:
            self.alerteInfos("Aucune correspondance trouvee", couleur="grey")
            self.dlg.end_processing_error('majBdLanceur', 'Aucun resultat')
            QgsMessageLog.logMessage("[PERF-MAJ] ======= FIN CALLBACK (aucun resultat) =======", "PoleAerien", Qgis.Info)
            return

        # Resume
        if tt_trouve_ft > 0:
            self.alerteInfos(f"{tt_trouve_ft} MAJ FT a appliquer", couleur="grey")
        if tt_trouve_bt > 0:
            self.alerteInfos(f"{tt_trouve_bt} MAJ BT a appliquer", couleur="grey")
        QApplication.processEvents()

        t5 = time.perf_counter()
        QgsMessageLog.logMessage(f"[PERF-MAJ] Alertes resume: {t5-t2:.3f}s", "PoleAerien", Qgis.Info)

        # Reset barre progression
        self.dlg.smooth_progress.reset()
        QApplication.processEvents()

        t6 = time.perf_counter()
        QgsMessageLog.logMessage(f"[PERF-MAJ] TOTAL avant dialog: {t6-t0_callback:.3f}s", "PoleAerien", Qgis.Warning)

        # Confirmation
        label = "ATTENTION: action irreversible. Confirmer la MAJ?"
        choix, ok = QInputDialog.getItem(
            self.dlg, 'MAJ infra_pt_pot', label,
            ["ABANDONNER", "CONFIRMER"], 0, False
        )
        
        t7 = time.perf_counter()
        QgsMessageLog.logMessage(f"[PERF-MAJ] Dialog confirmation: {t7-t6:.3f}s (attente user)", "PoleAerien", Qgis.Info)

        if ok and choix == "CONFIRMER":
            lyr = self.dlg.MajcomboBox_infra_pt_pot.currentLayer()
            if not lyr:
                self.alerteInfos("Couche infra_pt_pot non disponible", couleur="red")
                self.dlg.end_processing_error('majBdLanceur', 'Erreur')
                return
            tb_pot = lyr.name()

            # CRITICAL-001 FIX: Utiliser MAJ asynchrone pour éviter le freeze UI
            self.alerteInfos("Lancement MAJ BD en arrière-plan...", couleur="grey")
            self._cancel_maj_bd = False

            # Stocker les données pour affichage après MAJ
            self._maj_pending_data = {
                'lst_trouve_ft': lst_trouve_ft,
                'lst_trouve_bt': lst_trouve_bt,
                'tt_trouve_ft': tt_trouve_ft,
                'tt_trouve_bt': tt_trouve_bt
            }
            
            # Lancer MAJ asynchrone
            self.maj_workflow.start_updates(tb_pot, lst_trouve_ft, lst_trouve_bt)

            # Enregistrement pour annulation
            if self.maj_workflow.update_task:
                self.dlg.register_task('majBdLanceur', self.maj_workflow.update_task)
            self.dlg.register_cancel_callback('majBdLanceur', self._request_cancel_maj_bd)
        else:
            self.dlg.smooth_progress.reset()
            self.dlg.end_processing_error('majBdLanceur', 'Abandonne')

    def _onMajUpdateFinished(self, result):
        """
        CRITICAL FIX: Exécution MAJ sur Main Thread (obligatoire pour QGIS).
        Les modifications de couche ne peuvent pas être faites depuis un Worker Thread.
        """
        layer_name = result.get('layer_name')
        data_ft = result.get('data_ft')
        data_bt = result.get('data_bt')
        ft_count = result.get('ft_count', 0)
        bt_count = result.get('bt_count', 0)
        
        ft_updated = 0
        bt_updated = 0
        
        # Callback pour afficher progression dans le plugin
        def progress_cb(msg, pct):
            self.alerteInfos(msg, couleur="grey")
            self.dlg.smooth_progress.set_target(pct)
            QApplication.processEvents()
        
        def should_cancel():
            return getattr(self, '_cancel_maj_bd', False)

        def finish_cb(ft_done, bt_done):
            nonlocal ft_updated, bt_updated
            ft_updated = ft_done
            bt_updated = bt_done
            if hasattr(self, '_maj_pending_data'):
                data = self._maj_pending_data
                if ft_updated > 0 and data.get('lst_trouve_ft') is not None:
                    self._afficherTableau(data['lst_trouve_ft'], f"FT mis à jour ({ft_updated})", "#69db7c")
                if bt_updated > 0 and data.get('lst_trouve_bt') is not None:
                    self._afficherTableau(data['lst_trouve_bt'], f"BT mis à jour ({bt_updated})", "#69db7c")
                del self._maj_pending_data

            self.alerteInfos(f"MAJ terminée: {ft_updated} FT, {bt_updated} BT", couleur="green")
            self.dlg.smooth_progress.set_target(100)
            self.dlg.end_processing_success('majBdLanceur', 'MAJ terminée')
            self.dlg.unregister_cancel_callback('majBdLanceur')

        def error_cb(msg):
            self.alerteInfos(f"Erreur MAJ BD: {msg}", couleur="red")
            self.dlg.smooth_progress.reset()
            self.dlg.end_processing_error('majBdLanceur', 'Erreur MAJ')
            self.dlg.unregister_cancel_callback('majBdLanceur')
            if hasattr(self, '_maj_pending_data'):
                del self._maj_pending_data

        try:
            # UI-FREEZE-FIX: Utiliser MAJ SQL background pour UI 100% réactive
            self.maj_workflow.start_updates_sql_background(
                layer_name,
                data_ft,
                data_bt,
                progress_cb,
                finish_cb,
                error_cb,
            )
        except Exception as e:
            error_cb(str(e))

    def _onMajUpdateError(self, err):
        """CRITICAL-001 FIX: Callback erreur MAJ BD asynchrone"""
        self.alerteInfos(f"Erreur MAJ BD: {err}", couleur="red")
        self.dlg.smooth_progress.reset()
        self.dlg.end_processing_error('majBdLanceur', 'Erreur MAJ')
        if hasattr(self, '_maj_pending_data'):
            del self._maj_pending_data

    def _request_cancel_maj_bd(self):
        """Demande d'annulation de la MAJ BD (prise en compte entre lots)."""
        self._cancel_maj_bd = True
        self.alerteInfos("Annulation en cours...", couleur="orange")
        # Annuler la tâche SQL background si en cours
        if hasattr(self, 'maj_workflow') and self.maj_workflow:
            self.maj_workflow.cancel_sql_background()
        