# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PoleAerienDialog
                                 A QGIS plugin
 Controle de donner comac
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-03-01
        git sha              : $Format:%H$
        copyright            : (C) 2022-2026 by NGE ES
        email                : contact@nge-es.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sip

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QTimer, QSize, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.core import QgsProject
from qgis.gui import QgsMapLayerComboBox

from .async_tasks import SmoothProgressController

def _sip_is_deleted(obj):
    try:
        return sip.isdeleted(obj)
    except RuntimeError:
        return True

# Load base .ui
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'interfaces/PoleAerien_dialog_base.ui'))

# Button icons mapping
BUTTON_ICONS = {
    'majBdLanceur': 'icon-play.svg',
    'cap_ftLanceur': 'icon-play.svg',
    'cap_comacLanceur': 'icon-play.svg',
    'C6BdLanceur': 'icon-play.svg',
    'c6_c3a_bdLanceur': 'icon-play.svg',
    'c6Lanceur': 'icon-play.svg',
    'boutonCheminEtudeCapFt': 'icon-folder-open.svg',
    'boutonCheminEtudeComac': 'icon-folder-open.svg',
    'C6BdboutonCheminFichiersC6': 'icon-folder-open.svg',
    'boutonCheminC6_c6_c3a_bd': 'icon-excel.svg',
    'boutonCheminC7_c6_c3a_bd': 'icon-excel.svg',
    'boutonCheminC3A_c6_c3a_bd': 'icon-excel.svg',
    'boutonCheminExportComac': 'icon-export.svg',
    'C6BdboutonCheminExportDonnees': 'icon-export.svg',
    'boutonCheminExportDonnees_c6_c3a_bd': 'icon-export.svg',
    'c6BoutonCheminImport': 'icon-import.svg',
    'helpButton': 'icon-help.svg',
    'exporter': 'icon-export.svg',
    'boutonCheminExport': 'icon-folder-open.svg',
    # REQ-PLC6-002/005: nouveaux boutons
    'c6BoutonCheminSqlite': 'icon-import.svg',
    'c6BoutonCheminComac': 'icon-folder-open.svg',
}


class PoleAerienDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(PoleAerienDialog, self).__init__(parent)
        self.setupUi(self)
        
        self.plugin_dir = os.path.dirname(__file__)
        self.smooth_progress = SmoothProgressController(interval_ms=25, step=1)
        
        # Task management for cancel support
        self._active_tasks = {}  # btn_name -> QgsTask
        self._original_slots = {}  # btn_name -> original slot
        self._cancel_callbacks = {}  # btn_name -> callable
        
        # Layer sync connections
        self._layer_connections = []
        
        # NOTE: L'interface backup utilise QTabWidget natif, pas QStackedWidget
        # Les pages sont déjà définies dans le .ui, pas besoin de _build_pages()
        
        # Connect layer sync
        self._setup_layer_sync()
        
        # Setup icons
        self._setup_button_icons()
    
    
    def _setup_layer_sync(self):
        """Connect to QgsProject signals for dynamic layer sync.
        
        Refreshes all QgsMapLayerComboBox when layers are added/removed.
        """
        project = QgsProject.instance()
        
        # Connect signals
        conn1 = project.layersAdded.connect(self._on_layers_changed)
        conn2 = project.layersRemoved.connect(self._on_layers_changed)
        self._layer_connections = [conn1, conn2]
    
    def _on_layers_changed(self, *args):
        """Refresh all QgsMapLayerComboBox widgets when layers change."""
        _ = args  # Unused signal args
        # Find all QgsMapLayerComboBox in dialog
        for combo in self.findChildren(QgsMapLayerComboBox):
            # Preserve current layer without reset cycle
            current_layer = combo.currentLayer()
            if current_layer and current_layer.isValid():
                # Block signals to avoid cascade
                combo.blockSignals(True)
                combo.setLayer(current_layer)
                combo.blockSignals(False)
    
    def _setup_button_icons(self):
        """Apply SVG icons to all mapped buttons."""
        icon_size = QSize(20, 20)
        for btn_name, icon_file in BUTTON_ICONS.items():
            btn = getattr(self, btn_name, None)
            if btn:
                icon_path = os.path.join(self.plugin_dir, 'images', icon_file)
                if os.path.exists(icon_path):
                    btn.setIcon(QIcon(icon_path))
                    btn.setIconSize(icon_size)
    
    def showEvent(self, event):
        """Attach smooth progress to progressBar on first show."""
        super().showEvent(event)
        if hasattr(self, 'progressBar') and self.smooth_progress:
            self.smooth_progress.set_progress_bar(self.progressBar)
    
    # --- Page state management ---
    # NOTE: Interface backup utilise QTabWidget natif sans KPI badges
    # Ces méthodes sont des stubs pour compatibilité avec ui_state.py
    
    def set_page_status(self, page_idx, status):
        """Stub pour compatibilité - interface backup n'a pas de badges status."""
        pass
    
    def update_kpi(self, page_idx, kpi_name, text):
        """Stub pour compatibilité - interface backup n'a pas de KPI badges."""
        pass
    
    # --- Public API for visual feedback ---
    
    def register_task(self, btn_name, task):
        """Register a task for cancel support."""
        self._active_tasks[btn_name] = task

    def register_cancel_callback(self, btn_name, callback):
        """Register a cancel callback for main-thread operations."""
        self._cancel_callbacks[btn_name] = callback

    def unregister_cancel_callback(self, btn_name):
        """Unregister cancel callback after completion."""
        if btn_name in self._cancel_callbacks:
            del self._cancel_callbacks[btn_name]
    
    def unregister_task(self, btn_name):
        """Unregister task after completion."""
        if btn_name in self._active_tasks:
            del self._active_tasks[btn_name]
    
    def store_original_slot(self, btn_name, slot):
        """Store original slot for reconnection after cancel."""
        self._original_slots[btn_name] = slot
    
    def start_processing(self, btn_name, message="Traitement en cours..."):
        """Start processing - button becomes 'Annuler'"""
        btn = getattr(self, btn_name, None)
        if not btn:
            return
        
        # Store original state
        btn._original_text = btn._original_text if hasattr(btn, '_original_text') else btn.text()
        btn._btn_name = btn_name
        btn._is_processing = True
        
        # Change to Cancel mode
        btn.setText("Annuler")
        btn.setEnabled(True)
        btn.setStyleSheet("""
            QPushButton {
                background-color: #e53e3e;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 24px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #c53030;
            }
        """)
        
        # Set cancel icon
        icon_path = os.path.join(self.plugin_dir, 'images', 'icon-stop.svg')
        if os.path.exists(icon_path):
            btn.setIcon(QIcon(icon_path))
        
        # Disconnect old slot, connect cancel
        btn.blockSignals(True)
        try:
            btn.clicked.disconnect()
        except TypeError:
            pass
        btn.clicked.connect(lambda: self._cancel_task(btn_name))
        btn.blockSignals(False)
        
        # Force UI refresh
        QCoreApplication.processEvents()
    
    def end_processing_success(self, btn_name, message="Terminé"):
        """End processing with success state"""
        btn = getattr(self, btn_name, None)
        if btn:
            btn._is_processing = False
            self._stop_button_animation(btn)
            btn.setText(message)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #48bb78;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    padding: 10px 24px;
                    font-weight: bold;
                }
            """)
            btn.setEnabled(True)
            # Use shorter delay and store timer ref
            btn._reset_timer = QTimer.singleShot(2000, lambda: self._safe_reset_button(btn, btn_name))
            # Force UI refresh
            QCoreApplication.processEvents()
    
    def end_processing_error(self, btn_name, message="Erreur"):
        """End processing with error state"""
        btn = getattr(self, btn_name, None)
        if btn:
            btn._is_processing = False
            self._stop_button_animation(btn)
            btn.setText(message)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #fc8181;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    padding: 10px 24px;
                    font-weight: bold;
                }
            """)
            btn.setEnabled(True)
            # Use shorter delay and store timer ref
            btn._reset_timer = QTimer.singleShot(3000, lambda: self._safe_reset_button(btn, btn_name))
            # Force UI refresh
            QCoreApplication.processEvents()
    
    def _animate_button_processing(self, btn, message):
        """Animate dots on button during processing"""
        btn._processing = True
        btn._dots = 0
        btn._proc_msg = message
        
        def update_dots():
            if not getattr(btn, '_processing', False):
                return
            btn._dots = (btn._dots + 1) % 4
            btn.setText(f"{btn._proc_msg}{'.' * btn._dots}")
            QTimer.singleShot(400, update_dots)
        
        btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #4299e1;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 24px;
                font-weight: bold;
                font-size: 11pt;
                min-width: 120px;
                min-height: 36px;
            }}
        """)
        update_dots()
    
    def _stop_button_animation(self, btn):
        """Stop button animation"""
        btn._processing = False
    
    def _cancel_task(self, btn_name):
        """Cancel running task and reset button."""
        task = self._active_tasks.get(btn_name)
        if task is not None and not _sip_is_deleted(task):
            try:
                task.cancel()
            except RuntimeError:
                pass
        elif btn_name in self._cancel_callbacks:
            try:
                self._cancel_callbacks[btn_name]()
            except Exception:
                pass
        if btn_name in self._active_tasks:
            del self._active_tasks[btn_name]
        if btn_name in self._cancel_callbacks:
            del self._cancel_callbacks[btn_name]
        
        btn = getattr(self, btn_name, None)
        if btn:
            btn._is_processing = False
            self._safe_reset_button(btn, btn_name)
            self.smooth_progress.reset()
            QCoreApplication.processEvents()
    
    def _safe_reset_button(self, btn, btn_name):
        """Reset button safely with signal blocking."""
        if not btn or getattr(btn, '_is_processing', False):
            return
        self._reset_button(btn)
    
    def _reset_button(self, btn):
        """Reset button to original state and reconnect original slot."""
        from .ui_pages import STYLES
        
        # Block signals during reconnection
        btn.blockSignals(True)
        
        # Disconnect cancel slot
        try:
            btn.clicked.disconnect()
        except (TypeError, RuntimeError):
            pass
        
        # Restore text and style
        if hasattr(btn, '_original_text'):
            btn.setText(btn._original_text)
        
        # Restore play icon
        icon_path = os.path.join(self.plugin_dir, 'images', 'icon-play.svg')
        if os.path.exists(icon_path):
            btn.setIcon(QIcon(icon_path))
        btn.setStyleSheet(STYLES['btn_primary'])
        
        # Reconnect original slot
        btn_name = getattr(btn, '_btn_name', None)
        if btn_name and btn_name in self._original_slots:
            btn.clicked.connect(self._original_slots[btn_name])
        
        btn.blockSignals(False)
        btn.setEnabled(True)
        
        # Force UI refresh
        QCoreApplication.processEvents()

    def closeEvent(self, event):
        """Cleanup on dialog close."""
        # Clear task references WITH sip.isdeleted() checks
        # QgsTask ownership belongs to QgsTaskManager - objects may be deleted
        for btn_name, task in list(self._active_tasks.items()):
            if task is not None:
                try:
                    if not sip.isdeleted(task):
                        # Objet encore valide
                        pass
                except RuntimeError:
                    # Objet déjà supprimé
                    pass
        self._active_tasks.clear()

        # Clear slot references
        self._original_slots.clear()

        # Stop progress animation
        if self.smooth_progress:
            self.smooth_progress.reset()

        # Disconnect layer sync signals
        self._disconnect_layer_sync()

        # Disconnect navigation signal (si interface dynamique)
        if hasattr(self, 'moduleList'):
            try:
                self.moduleList.currentRowChanged.disconnect()
            except (TypeError, RuntimeError):
                pass

        super().closeEvent(event)

    def _disconnect_layer_sync(self):
        """Disconnect layer sync signals."""
        project = QgsProject.instance()
        try:
            project.layersAdded.disconnect(self._on_layers_changed)
            project.layersRemoved.disconnect(self._on_layers_changed)
        except (TypeError, RuntimeError):
            pass
        self._layer_connections.clear()

    def cleanup(self):
        """Explicit cleanup for plugin unload."""
        # Clear task references WITH sip.isdeleted() checks
        # QgsTask ownership belongs to QgsTaskManager - objects may be deleted
        for btn_name, task in list(self._active_tasks.items()):
            if task is not None:
                try:
                    if not sip.isdeleted(task):
                        # Objet encore valide
                        pass
                except RuntimeError:
                    # Objet déjà supprimé
                    pass
        self._active_tasks.clear()
        self._original_slots.clear()

        # Disconnect layer sync
        self._disconnect_layer_sync()
